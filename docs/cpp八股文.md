# 一、C++语言基础

## 1. 基本语法

### 1.1 指针和引用相关

#### 1.1.1 指针和引用的区别？

- **指针**是一个变量，其指向一个地址，本身也占用内存；**引用**只是个原变量别名，本身不占用内存。
- **指针**可以为空，并且可以改变指向；而**引用**必须初始化且不能再改变。
- `sizeof`函数作用于**指针**会获得指针的大小；作用于**引用**会获得原变量的尺寸。
- **指针**作为参数传递时，也会拷贝一个形参副本，指向同一个内存区域，修改这个副本指针不会影响到原指针；而**引用**传参只是拷贝了一个别名，修改后会影响原始变量。
- **指针**可以有多级，即存在指向指针的指针；而**引用**只能有一级。

#### 1.1.2 参数传递时什么时候该用指针，什么时候该用引用？ 什么时候值传递？

|              | 只使用传递过来的值，而不对值进行修改 | 需要修改传递过来的值 |
| ------------ | ------------------------------------ | -------------------- |
| 内置数据类型 | 按值传递（小型结构）                 | 指针传递             |
| 数组         | 指针传递                             | 指针传递             |
| 结构         | 指针或引用（较大的结构）             | 指针或引用           |
| 类、对象     | 引用传递                             | 引用传递             |

- 值传递拷贝的数据就是传递的**<font color='cornflowerblue'>变量的值（传递值）</font>**，当变量较大时效率会比较慢；
- 指针传递拷贝的数据是**<font color='cornflowerblue'>指针变量的值（传递值）</font>**，固定的4字节（32位系统）或8字节（64位系统）；
- 引用传递拷贝的数据是**<font color='cornflowerblue'>变量的地址（传递地址）</font>**，固定的4字节（32位系统）或8字节（64位系统），为这个地址创建别名；
- 需要返回函数内部局部变量的内存时用**指针传递**，返回局部变量的引用是无意义的（这个局部变量在函数作用域结束后会销毁）；
- 对栈空间比较敏感（如递归）时使用**引用传递**，不需要创建临时变量，开销更小；
- 类对象作为参数传递时用**引用传递**，避免由于拷贝构造副本带来的开销（标准方式）。

#### 1.1.3 引用的底层实现？

在C++中，**<font color='cornflowerblue'>引用本质上是一个指针</font>**。因此，引用也是占用内存空间的，和指针变量一致。但是，**引用不允许其寻址，也就是引用并不知道自己的地址在哪**。相对来说，指针除了指向的地址还有一个自身的地址。

由于底层使用指针实现，所以引用也是存储了所引用对象的地址，但它的语法和使用比指针更加简洁。**<font color='cornflowerblue'>引用在使用时，会被编译器直接替换为变量的地址，这使得引用在运行时与直接访问变量几乎没有性能差别。</font>**

#### 1.1.4 一个指针占用多少内存？

- 在32位系统中，占用4字节；

- 在64位系统中，占用8字节。


#### 1.1.5 常量指针和指针常量的区别？

- **常量指针（`const int *`）**：是底层常量，可以改变指针的指向，但不能通过指针改变指向对象的值；
- **指针常量（`int * const`）**：是顶层常量，不可以改变指针的指向，但可以通过指针改变指向对象的值。

#### 1.1.6 函数指针和指针函数的区别？

- **函数指针**：是一个指向函数的指针，该指针指向函数的地址（代码段），通过这个指针可以调用这个函数；由于指针可以动态地调整指向的函数地址，因此**<font color='cornflowerblue'>函数指针是实现运行时多态的基础（如虚函数指针）</font>**。

  ```c++
  // 例：
  int add(int a, float b) {
      return a + static_cast<int>(b);
  }
  
  // 函数指针
  int (*func_ptr)(int, float) = &add;
  ```

- **指针函数**：是一个函数，返回值是某个类型的指针。

  ```c++
  int* function_name(parameters);
  ```

#### 1.1.7 数组名和指针的区别？

对于如下的数组名`a`和指向数组的指针`p`：

```cpp
int a[10];	
int (*p)[10] = &a;  // &a取地址
```

- `a`作为数组名，实际上等价于`&a[0]`，即**数组中第一个元素`a[0]`的地址<font color='red'>（可以理解为一种指针常量的作用，但不是指针）</font>**，无法修改其指向等。可以通过`a[i]`访问数组元素并修改，但是不能对`a`进行赋值操作；且对a进行取地址是对数组的第一个元素取地址，而不是指针地址；`sizeof`获得的是数组的大小。
- `p`是真正的指针，指向数组`a`的地址。可以通过`*p`（解引用）来获得数组`a`（即数组本身 `int[10]`，不是地址）。通过`(*p)[i]`等价于`a[i]`访问数组元素，等价于 `a[i]`。且可以改变指向。`sizeof`获得的指针的大小。
- **数组名用于形参传递时，一般会退化成指向数组的指针**。

#### 1.1.8 野指针和悬空指针

- **野指针**：没有被初始化的指针；

  解决方案：编译器在指针定义时默认将其初始化为nullptr，如果直接使用编译器会报错。

- **悬空指针**：指针指向的内存已经被释放；

  解决方案：及时销毁或置空指针；使用智能指针。







### 1.2 常见的关键字

#### 1.2.1 const关键字的作用？

`const`主要用来定义常量和保护变量不被修改：

- **定义常量**：使用`const`可以定义一个不可修改的常量，**`const`常量的默认链接方式是内部链接（只有该源文件可见）**，可以将其定义在头文件中而不会引起重复定义问题，每个包含该头文件的源文件都各自拥有一个`const`常量的副本。

  ```cpp
  // constants.h
  const int MAX_VALUE = 100;
  ```

- **修饰变量/成员变量**：用`const`修饰一个变量，阻止这个变量被改变，在定义变量时必须初始化。

  ```cpp
  // 变量
  const int value;
  
  // 成员变量
  class MyClass {
  public:
      MyClass(int v) : value(v) {}
      void printValue() const {
          std::cout << value << std::endl;
      }
  private:
      const int value;
  };
  
  ```

- **修饰函数参数**：用`const`修饰一个函数的参数，表示在函数内部不能修改这个参数，一般搭配引用或指针使用。

  ```cpp
  void printValue(const int value) {
      // value不能在函数内部被修改
      printf("%d\n", value);
  }
  ```

- **修饰指针变量**：`const`也可以修饰指针变量，分为：常量指针和指针常量。

  ```cpp
  const int* value;	// 常量指针，value可以改变指向，，但不能改变所指向地址的变量值，底层const
  int* const value;	// 指针常量，可以改变指向地址的变量值，但不能改变指向，顶层const
  ```

- **修饰返回值**：表示返回的值不能修改，通常用于返回引用类型。

  ```cpp
  class MyClass {
  public:
      const int& getValue() const {
          return value;
      }
  private:
      int value;
  };
  ```

- **修饰类成员函数**：表示该成员函数不能修改类的成员变量，显式用`mutable`修饰的除外。

#### 1.2.2 constexpr和const的区别？

常量又分为**编译期常量**和**运行期常量**。编译期常量，要求变量的值必须**在编译时就能确定**，而运行期常量是在程序运行期间可以**通过计算得出的常量**。编译期常量使得C++程序能够在编译阶段执行更多的计算，带来性能优化、安全性等好处。

C++ 11之前，**这两个都是由`const`来定义**，由编译器决定const修饰的变量是编译期常量还是运行期常量。为了能够显式地指定是编译期常量，C++ 11 中引入了常量表达式`constexpr`来定义编译期常量。它和`const`之间的区别：具体来说：

- `const`既可以定义编译期常量也可以定义运行期常量，`constexpr`来定义编译期常量；
- `constexpr`需要确保变量和函数**在编译期计算出结果**，编译器会对其严格检查，如果无法在编译期确定该值，则会报错；
- **`constexpr`函数**在编译时执行，并且其参数必须是常量表达式，返回值也必须是常量表达式，且内部被要求是非常简单，如只有一个return语句（C++11)；
- 对于类的构造函数，不能是`const`的（因为要构造对象，会修改对象状态），但是可以是`constexpr`的，要求**函数体只能包含可在编译时执行的语句，所有的成员变量初始化必须在初始化列表中进行，参数也必须是编译时常量（`constexpr`）**。

#### 1.2.3 static关键字的作用？

`static`关键字主要用于控制变量的**生命周期**、**作用域**以及**访问权限**。

- **修饰局部变量**：可以让局部变量的**生命周期持续到程序结束**，不会随着函数的结束而销毁，但是作用域仍然局限于定义它的函数内部，可以用于多次执行一个函数时保存变量值等。

- **修饰全局变量和全局函数**：限制它们的**作用域为定义它们的源文件**，防止它们在其他源文件中被调用。

  ```cpp
  // 主要用于在.h文件中声明
  在 .h 文件中声明静态变量（static）：
      作用域：每个包含此头文件的 .cpp 文件都会有自己的一份静态变量实例。
      链接性：静态变量在每个翻译单元（.cpp 文件）中都是独立的，不会造成链接冲突。
      内存使用：每个包含头文件的翻译单元都有自己的静态变量副本，可能导致不必要的内存占用。
  在 .h 文件中声明静态函数（static）：
      作用域：静态函数的作用域限于声明它的翻译单元，因此它只能在包含它的 .cpp 文件中使用。
      链接性：每个包含此头文件的 .cpp 文件都会有自己的一份静态函数副本，不会导致链接冲突。
  .h文件中的全局变量和函数（不使用 static）：
      作用域：这些全局变量和函数可以在任何翻译单元中访问。
      链接性：它们的链接性是 external（外部），因此在整个程序中只会有一份实例。需要确保在所有包含这个头文件的.cpp文件中只声明而不定义全局变量或函数，定义		  应该在一个.cpp 文件中进行。
  ```

- **修饰类成员变量**：该成员变量属于类而不属于任何一个对象，因此也需要**在类外部定义**。

- **修饰类成员函数**：函数属于类而不属于对象，可以在没有实例时调用，但**只能访问类内的静态成员变量**。

#### 1.2.4 volatile关键字的作用？

`volatile`指易变的，表示变量可能在任何时候被外部因素修改，**编译器不应该对该变量的访问进行优化（不添加到缓存中，每次从内存中读取）**。在多线程编程中，`volatile`可以用于修饰共享变量，确保一个线程对变量的修改能被另一个线程立即看到。

#### 1.2.5 extern关键字的作用？

`extern`的作用主要为声明外部变量（全局变量、函数），告诉编译器这个变量或函数是**在其他文件中定义的，并且在当前文件中可以使用**。使用 `extern` 关键字可以帮助在多个源文件之间共享变量或函数，而不需要在每个文件中重复定义。

除此之外，在C++中引用C语言的代码时，需要告诉编译器按照 C 的链接规则处理这些函数，则需要通过 `extern "C"`来实现**，当在 C++ 代码中声明或定义 C 函数时，需要将函数声明放在 `extern "C"` 块中**。

#### 1.2.6 #define和typedef的区别？

它们都可以**用来创建别名**，但它们的用途和机制有很大不同。

- **处理阶段不同**：`#define`是预处理指令，在预处理阶段起作用；`typedef`是一个关键字，在编译阶段处理；
- **使用目的不同**：`#define`常用于定义常量、宏函数，在编译之前进行文本替换，还可以用于条件编译防止头文件重复定义；`typedef`主要用于创建现有复杂类型的别名，使得代码更加简化和具有可读性；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；`typedef`在编译时会进行类型检查；

#### 1.2.7 都能定义常量，#define和const的区别？

`#define` 和 `const` 都可以用来定义常量，但它们在使用方式、语法、作用域和编译时的处理上有很大的不同。以下是它们的主要区别：

- **处理阶段不同**：`#define`是预处理指令，在预处理阶段起作用；`const` 是一个关键字，在编译阶段处理；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；`const` 在编译时会进行类型检查，可以在编译时捕捉到类型相关的错误；
- **是否占用内存**：`#define`定义的常量是直接替换为了对应文本，不会占用内存；`const` 定义的常量会存在内存的常量区中，需要内存空间。

#### 1.2.8 #define和函数的区别？

`#define`宏和函数都**用于代码的重用**，允许定义一段代码然后再多个地方使用。它们的区别：

- **处理阶段不同**：`#define`是预处理器指令，在预处理阶段完成替换；函数是经过编译器编译生成可执行代码并链接，在运行时跳转到具体调用函数；
- **处理方式不同**：`#define`是直接文本替换，不存在函数调用，无需返回值；函数则需要跳转到具体调用位置执行，有返回值；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；函数在编译时会进行类型检查；

#### 1.2.8 #define和内联函数的区别？

`#define`宏和内联函数都**用于代码的重用**，允许定义一段代码然后再多个地方使用。它们的区别可以参考【#define和函数的区别】。

**需要多注意的是**：内联函数也不会产生函数调用的开销，而是通过**直接把函数代码嵌入到执行内联函数的位置**。

#### 1.2.10 override关键字和final关键字的作用？

- **override 关键字**

  当需要在子类中重写父类的**<font color='cornflowerblue'>虚函数（必须是虚函数）</font>**时，可以在后面加上override关键字，显式地指定这是重写的方法，例如：

  ```c++
  class A {
  public:
  	virtual void foo();		// 虚函数
  };
  
  class B: public A {
  public:
  	void foo() override;	// 继承自A重写的方法
  };
  ```

- **final 关键字**

  当**<font color='cornflowerblue'>不希望类被继承或类中的某个虚函数被重写</font>**，可以在类名或虚函数后面添加final关键字，表示不能被继承或重写，例如：

  ```c++
  class A {
  public:
  	virtual void foo() final;		// 虚函数
  };
  
  class B final: public A {	// 类B使用了final修饰
  public:
  	void foo() override;	// 继承自A重写的方法，会报错，因为A中通过final关键字表明这个函数不能被重写
  };
  
  class C: B {				// 报错，B不能被继承
      
  };
  ```

#### 1.2.11 mutable关键字的作用？

对于被const修饰的成员函数，它不能修改成员变量的值，除非**使用mutable关键字修饰这个成员变量**。意味着这个成员变量是**可以被const成员函数修改的**。

#### 1.2.12 explicit关键字的作用？

explicit关键字用于修饰类的构造函数，意味着禁止发生相应的隐式类型变换，只能显式的方式进行类型转换，注意：

- explicit只能用于类的构造函数声明上；
- explicit作用于单个参数的构造函数上（即转换构造函数），因为涉及到类型转换；
- 被explicit修饰构造函数的类，不能够发生相应的隐式类型转换。

```cpp
class MyClass {
public:
    explicit MyClass(int x) {
        // 转换构造函数
    }
};

int main() {
    MyClass obj1 = 10;    // 错误：由于 explicit，不能进行隐式转换
    MyClass obj2(10);     // 正确：显式调用转换构造函数
    return 0;
}

```



### 1.3 数据类型和内存大小

|   类型    |  32位  |  64位  |
| :-------: | :----: | :----: |
|   char    | 1 字节 | 1 字节 |
|   short   | 2 字节 | 2 字节 |
|    int    | 4 字节 | 4 字节 |
|   float   | 4 字节 | 4 字节 |
|  double   | 8 字节 | 8 字节 |
|   long    | 4 字节 | 8 字节 |
| long long | 8 字节 | 8 字节 |
|   指针    | 4 字节 | 8 字节 |

### 1.4 字符串相关

#### 1.4.1 strlen和sizeof的区别？

- strlen是处理字符的**库函数**；sizeof是C++**运算符**，并不是函数，结果**在编译器获得**。
- strlen只能用于C风格字符串（以`'\0'`表示结尾）；sizeof可以用于任意数据的类型或数据本身。
- sizeof是在编译器获取结果，因此无法获取在运行期动态分配的空间大小；



### 1.5 C++异常处理

常见的异常：

- 数组下标越界；
- 除法计算时除数为0；
- 动态分配内存时空间不足；
- ...

#### 1.5.1 try、throw和catch关键字

C++主要的异常处理机制，`try`、`throw`和`catch`关键字的搭配使用，例：

```c++
double m = 1, n = 0;
try {
	if (n == 0) throw -1;  // 抛出int异常
	else if (m == 0) throw -1.0; // 抛出double异常
	else cout << m / n << endl;
}
catch (double d) {	// 捕获double类型异常
	cout << "catch double" << d << endl;
}
catch (int i) {		// 捕获int类型异常
	cout << "catch int" << i << endl;
}
catch (...) {		// 捕获所有类型异常，不推荐
    cout << "catch all" << endl;
}
```

#### 1.5.2 函数的异常声明列表

在定义函数时，提前指出函数所能抛出异常类型的列表，例如：

```c++
int fun() throw(int,double){...}
```

上述代码表明fun函数**可能会抛出int或double类型的异常**。如果`throw()`中为空，说明不会抛出任何异常。如果不加`throw`则是可以抛出所有异常。编译器可以根据 `throw` 列表做出一些优化，比如减少异常处理相关的开销（但实际效果可能依赖具体编译器），调用者可以更好地理解函数的行为，从而在使用时进行适当的异常处理。

#### 1.5.3 有哪些常见的异常类型？

C++中存在一个标准异常类`exception`，常见的一些异常都是继承自这个类，常见的有：

- `bay_typeid`：使用typeid运算符获取类型信息时，操作对象是多态类的指针，且指向NULL，则会抛出这个异常；
- `bad_cast`：使用dynamic_cast进行基类到派生类的强制转换时，如果不安全，则抛出此异常；
- `bad_alloc`：使用new运算符动态分配内存时，若空间不足，则抛出此异常；
- `out_of_range`：对于容器（vector、string）利用下标访问数据时，下标越界，则抛出此异常。





### 1.x 其他基础内容

#### 1.x.1 变量的定义和声明的区别？

- 声明仅仅是将变量的位置和类型告诉编译器，并不实际为变量分配内存；定义是为变量分配内存空间。
- 相同的变量可以多次声明；但只能定义一次（分配一次内存）。

#### 1.x.2 C++和python的区别？

- C++是**编译型语言**，代码在允许前需要在**特定平台**编译成机器代码，后面就不需要再编译了；Python是**解释型语言**，每次都需要经过翻译和解释过程才可以执行。因此在实际运行中，C++通常具有更高的执行效率和性能，而Python方便跨平台，且开发速度快；
- C++需要**手动管理内存**，这也是C++语言的特色，可以有更高的性能但也容易出现内存泄漏等问题；Python有**自动垃圾回收机制**；
- C++定义变量是**静态类型**，在编译期确定，需要显示声明；Python变量是**动态类型**，在运行时确定，无需显式声明；
- C++适合系统编程、实时系统和高性能计算等需要高效的场景；Python适合Web开发、数据科学、机器学习、自动化脚本等设计开发。

#### 1.x.3 C++和JAVA的区别？

- C++是**编译型语言**，代码在允许前需要在**特定平台**编译成机器代码，后面就不需要再编译了；JAVA是**解释型语言**，需要编译成字节码，然后再JAVA虚拟机(JVM)上解释执行，可移植性更强；
- C++需要**手动管理内存**，这也是C++语言的特色，可以有更高的性能但也容易出现内存泄漏等问题；JAVA有**自动垃圾回收机制**；
- C++**支持指针**，允许直接操作内存地址；JAVA**不支持指针**，避免了直接对内存的操作，提高了安全性；
- C++既支持**面向过程也支持面向过程**；JAVA几乎所有代码**都是通过类和对象的形式**组织的；
- C++有丰富的标准库和第三方库，但使用起来比较复杂；JAVA拥有**庞大的标准库和第三方库生态系统**（如Spring），使用相对简单；
- C++通过**多继承、抽象类**等方式实现继承和多态；JAVA主要通过**接口**来实现，更加简易。
- C++适合系统编程、实时系统和高性能计算等需要高效的场景；JAVA适合企业级应用开发、Web开发、移动应用开发、分布式系统开发等。

#### 1.x.4 C++中初始化和赋值的区别？

初始化和赋值都涉及**将值分配给变**量，它们的区别在于**发生的时间和操作对象的状态**。特别是在涉及类对象时，初始化和赋值之间的区别更加显著。

- **初始化**是指变量创建时为其分配初始值的过程，发生在对象或变量的生命周期开始时；**赋值**是变量已经存在后，将一个新的值分配给该变量的过程。
- 类对象的**初始化**时通过构造函数来实现的；**赋值**是通过赋值操作符`=`来实现

#### 1.x.5 C++中直接初始化和拷贝初始化的区别？

- **直接初始化**：通过`()`或`{}`进行初始化的一种方式，通常是直接调用构造函数；

  ```c++
  std::string str1("Hello");  // 直接初始化
  int b(10);                  // 直接初始化
  std::string str2{"Hello"};  // 使用列表初始化的直接初始化
  int c{10};                  // 使用列表初始化的直接初始化
  std::string str3(str1);		// 直接初始化，调用拷贝构造函数
  ```

- **拷贝初始化**：使用等号`=`进行初始化的一种方式，通常会调用拷贝构造函数或移动构造函数；如果右侧是与左侧不同类型的表达式，**会发生隐式的类型转换**。

  ```cpp
  std::string str1 = "Hello";  // 拷贝初始化，构建临时对象，然后拷贝，会发生隐式类型转换（字符串字面值const char*->std::string）
  int a = 10;                  // 拷贝初始化，构建临时对象，然后拷贝，不会发生隐式类型转换（int->int）
  std::string str2 = str1;	 // 拷贝初始化，调用拷贝构造函数，不会发生隐式类型转换（string->string）
  ```

> 在现代编译器优化下，拷贝初始化中创建临时对象的过程通常会被优化掉，直接调用构造函数创建对象（**但依然是调用的拷贝构造函数**）。

#### 1.x.6 形参和实参的区别？

- 形参是在函数列出的参数，用于指定函数所需要的输入；实参是用于初始化形参的实际数据。
- 形参只在函数内部有效，在函数被调用时分配内存，函数结束后立刻销毁；实参的作用域是函数调用的上下文。
- 数据传送是单向的，只能把实参的值传输给形参，而不能反向传输。
- 如果形参是引用类型，那么形参只是实参的一个别名，它们访问同一个内存地址，修改形参实参也会发生变化。
- 如果形参是指针类型，它是一个新的指针，但是和实参指向同一个内存地址，修改形参实参不会变化，但修改指向变量的值会同时发生变化。

#### 1.x.7 静态变量什么时候初始化？

静态变量有两种主要类型：**静态全局变量**、**静态局部变量**和**静态成员变量**。它们的初始化规则如下：

- **静态全局变量**：静态全局变量**<font color='cornflowerblue'>在`main`函数执行之前会被初始化（和全局变量一致）</font>**，在程序的全局初始化阶段按照出现顺序初始化；
- **静态局部变量**：初始化时机是当程序第一次调用静态局部变量所在的函数时，即在**<font color='cornflowerblue'>第一次访问时初始化</font>**。

- **静态成员变量**：也是**<font color='cornflowerblue'>在`main`函数执行之前会被初始化</font>**，通常在类定义之外进行定义和初始化。

静态全局变量和静态成员变量的初始化发生在程序的全局初始化阶段，这个阶段是在程序启动时由运行时系统负责完成的，通常称为**静态初始化阶段**。这是为了确保在任何时候访问静态全局变量和静态成员变量时，它们都已经被初始化。

> 对于以上所有的静态变量，如果没有初始值，静态局部变量将被**默认初始化为其类型的零值**。

#### 1.x.8 `size_t`是什么？

**`size_t`** 是一个**<font color='cornflowerblue'>无符号整数类型</font>**，定义在 `<cstddef>` 头文件中。它用于表示**对象的大小和数组的索引等**。它的大小是平台相关的，通常在**32位系统上是4字节（32位），在64位系统上是8字节（64位）**。

- **无符号类型**：`size_t` 是无符号的，适合表示大小和索引，因为这些值不能为负。
- **平台相关**：`size_t` 的大小与平台相关，因此能够处理大于`int`或`long`所能表示的值。在64位系统上，`size_t` 的大小为8字节，可以处理更大的数据量。

## 2. 线程安全相关

### 2.1 a++ 和 int a = b 在C++中是否是线程安全的？

不安全。因为这些语句在编译为汇编指令**往往存在多条指令**，而多条指令就意味着可能存在线程安全问题。

```cpp
a++;
// 在汇编语言中存在三条指令：
// 1. 将a的内存值搬运到某个寄存器中
// 2. 将该寄存器中的值自增
// 3. 再将寄存器中的值搬运会a的内存中

int a = b;
// 在汇编语言中存在两条指令：（由于内存之间不能直接搬运，需要借助于寄存器）
// 1. 将b的值搬运到某个寄存器中
// 2. 再从该寄存器中搬运到a的内存地址
```

### 2.2 如何保证它们的原子性？

C++ 11中提供了一个新的原子操作库<atomic>，其中提供了一个模板类：`std::atomic`，可以保证一个变量的操作是原子的。它通过**底层的硬件指令（如 CPU 的原子操作指令）和内存屏障机制来实现原子性**，避免数据竞争（data race）问题。

```cpp
std::atomic<int> counter(0); // 定义一个原子整型变量

// 注意，这里不能用下面语句来定义，因为下面隐式的要调用拷贝构造函数，而std::atomic是利用=delete禁用拷贝构造函数的
std::atomic<int> counter = 0; ❌

// 在下面代码中的自增操作是原子的
void increment() {
    for (int i = 0; i < 1000; ++i) {
        ++counter; // 原子增操作
    }
}
```



## 3. C++内存分布

### 3.1 C++内存分布

C++中内存布局如下图所示，从低地址到高地址包含代码区、常量区、全局/静态区、堆区和栈区。

<img src="G:\code\study\CppStudy\docs\figures\C++内存分布2.png" alt="img" style="zoom:80%;" />



更详细一点的版本如下图所示：

<img src="G:\code\study\CppStudy\docs\figures\C++内存分布.png" alt="img" style="zoom:80%;" />

- **栈区**：存储函数内的局部变量、函数参数以及返回值，由编译器自动分配和释放，效率很高，但栈区由高低地址向低地址延申，空间地址有限。栈区的内存使用必须是**有序的、连续**的，且是严格按照**先进后出的原则**的。64位Linux系统上，默认的栈大小限制通常是8MB，超出会导致**<font color='red'>栈溢出</font>**。
- **堆区**：由程序员分配的内存，可以申请任意大小的内存且在任意时候释放，因此堆区内存分配是动态的且不一定连续（**单次分配的虚拟内存是连续的**，但是不同分配的内存不一定连续），因此堆区更加自由，但也容易出现内存碎片、内存泄漏等问题。
- **全局/静态区**：用来存储程序运行中的全局变量和静态变量，这些变量一般是**在编译阶段确定存储大小并确定它们的存储位置（实际内存分配其实也是在运行阶段）**，已初始化的全局/静态变量可能会放在`.data`段，而未初始化的全局/静态变量（通常初始化为0）可能放在`.bss`段。
- **常量存储区**：存放常量的内存区域，其中的常量不允许修改。
- **代码区**：存放函数的二进制代码。

### 3.2 堆区和栈区

#### 3.2.1 堆区和栈区的区别？

- **申请方式不同**：栈是由系统自动分配和回收，堆需要由程序员显式的申请和回收；
- **大小不同**：栈由高地址向低地址扩展，大小是固定的且较小；堆由低地址向高地址扩展，更大；
- **效率不同**：栈区由系统自动分配，效率很高；堆区的分配效率较慢，且手动管理容易出现内存泄漏或内存碎片；
- **存储内容不同**：在C++中，栈区一般用来存储局部变量、函数参数和返回地址等；堆区用来存储用户动态创建的变量。

#### 3.2.2 堆区和栈区哪个效率更高，为什么？

栈区的效率通常比较高，原因：

- 栈区内存的分配和释放**由编译器自动管理**，内存分配通常是通过调整栈指针来完成，**简单高效**；而堆区的内存分配和释放需要**动态内存分配函数，涉及到包括查找适当大小的空闲块等操作，开销较大**；
- **栈内存是连续的**，局部变量通常紧密排列，符合CPU缓存的访问模式，访问效率高；**堆内存分配的块可能是离散的**，且随着不断的分配和释放**会碎片化**，访问效率降低；
- 栈区由于自动管理不易出错，而堆区容易导致**内存泄漏等问题**，增加了管理复杂性。

#### 3.2.3 浅拷贝和深拷贝的区别

- **浅拷贝**

  只是拷贝出了一个指针，并没有重新申请内存，拷贝的指针和原来的指针指向同一块地址，容易出现对象销毁时多次重复释放资源、悬空指针的问题。

- **深拷贝**

  不止拷贝出一个指针，还会**在堆区开辟新的内存空间**来保存拷贝的资源。每个对象都拥有自己独立的资源，指向不同地址。

### 3.3 动态内存申请

#### 3.3.1 new/delete 和 malloc/free 的异同？

**相同点**：都是用来内存的动态申请和释放

**不同点**：

- new/delete 是C++的运算符；malloc/free 是C/C++的标准库函数
- new可以自动计算要分配的内存大小；malloc必须显式的指定
- new在分配内存失败时会抛出异常，不是返回NULL；malloc分配失败时返回NULL
- new/delete会调用对象的构造函数/析构函数；malloc/free不会
- new/delete返回的是具体类型指针；malloc/free返回的是void *，需要后续的类型转换

#### 3.3.2 既然已经有了malloc/free，为什么需要new/delete？

C++中引入了类和对象，对象创建的时候需要执行**构造函数**，销毁的时候需要调用**析构函数**。malloc/free不具有这个功能，而它们是标准库函数，已经编译了无法轻易地将构造函数和析构函数的功能加上去。因此，提出了new/delete运算符，能够在创建和销毁时去调用构造和析构函数。

#### 3.3.3 new/delete是如何实现的？

**new的实现**：先调用**operator new**标准库函数，分配足够大的原始为类型化的内存，然后运行该类型的构造函数，初始化构造对象，返回指向新分配并构造后对象的指针；

**delete的实现**：先对指向的对象运行析构函数，然后调用**operator delete**标准库函数释放该对象的内存。

#### 3.3.4 new p 和 delete p、new p[] 和 delete [] p

```cpp
int main() {
    // 单个对象的动态分配与释放
    int* p1 = new int(10);   // 分配一个整数并初始化为 10
    delete p1;               // 释放该整数的内存

    // 数组的动态分配与释放
    int* p2 = new int[5];    // 分配一个包含 5 个整数的数组
    delete[] p2;             // 释放该数组的内存

    return 0;
}
```

- `new[]` 操作符用于动态分配一块连续的内存空间来存储一个类型的数组，并**<font color='cornflowerblue'>为数组中的每个元素调用默认构造函数</font>**，返回的是**<font color='red'>指向这个数组的指针</font>**。

- `delete[]` 操作符用于释放之前用 `new[]` 分配的数组的内存，并**<font color='cornflowerblue'>调用数组中每个对象的析构函数</font>**，顺序时**<font color='red'>按照元素的逆序进行释放</font>**。

- `new[]`创建一个对象数组p时，需要保存数组的维度，因此需要**<font color='cornflowerblue'>多分配4个字节（32位系统）</font>**，存储在数组前面。`delete[]`会取出这个维度数从而知道要调用多少次析构函数。

  ```
  					p指针指向
                         ↓
  --------------------------------------------
  | Array Size (4 bytes) | Element 0 | Element 1 | ... | Element n-1 |
  --------------------------------------------
  ```

- 必须使用 `new` 和 `delete` 配对，以及 `new[]` 和 `delete[]` 配对。混用会导致未定义行为。

#### 3.3.5 malloc的底层原理

malloc和free是用来动态申请和释放内存的C语言标准库函数，它们所操作的内存主要位于**堆区**。

malloc分配内存可分为两种方式：

- **<font color='cornflowerblue'>分配小于 128K 的内存时：通过`brk`系统调用在堆区分配内存</font>**。其主要移动指针 `_enddata`(此时的 `_enddata` 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)

<img src="G:\code\study\CppStudy\docs\figures\brk申请.png" alt="img" style="zoom:50%;" />

- **<font color='cornflowerblue'>分配大于 128K 的内存时：通过 `mmap` 系统调用分配（munmap 释放）</font>**。通过 `mmap` 函数从堆和栈的中间（文件映射区）分配一块虚拟内存。

  <img src="G:\code\study\CppStudy\docs\figures\mmap分配内存.png" alt="img" style="zoom:50%;" />

在操作文件时，我们一般通过 `open()` 打开文件，然后使用 `mmap()` 将文件内容直接映射到虚拟内存上，这样我们就可以像操作内存一样操作文件的内容，这一块区域就是**文件映射区**，此时也就是从文件映射区“偷”了一块内存。

#### 3.3.6 malloc分配的是物理内存吗？

**不是，第一步只是虚拟内存，还没有和物理内存映射。**

以分配30KB为例：

- **步骤一**：调用`brk`系统调用，将`_edata`指针往高地址推30K，就成虚拟内存地址的分配；

- **步骤二**：当**<font color='cornflowerblue'>进程第一次访问这块新的虚拟内存地址时，会触发缺页中断，内核为这块新的虚拟地址对应上物理页</font>**。

  > **也就是说，如果用malloc分配了这块内容，然后从来不访问它，那么，对应的物理页是不会被分配的。**

#### 3.3.7 malloc实际上是构建的内存池？ 

malloc() 在分配内存的时候，**会预分配更大的空间作为内存池**。当我们调用brk()系统调用申请堆内存，仍然会为我们分配超过128KB字节的内存。即使你 malloc()的内存远小于128k也是一样。**==因此，就算是malloc(1)也是会分配较大的内存，略大于128K。==**

> **<font color='red'>为什么malloc要使用内存池来进行管理呢？</font>**
>
> **1. 提高效率：内存池预先分配一大块内存，然后在需要时从中分配小块，减少了频繁调用系统级别的内存分配开销**
>
> **2. 减少了内存碎片，内存池通过组织和管理内存块，能更好地利用内存空间，减少内存碎片，提高内存使用率。**

#### 3.3.8 free释放内存，会马上归还给操作系统吗？ 

- malloc 通过 **`brk()`** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；

  > **被ptmalloc使用双链表存起来**，当用户下一次申请内存时，会尝试从这个链表中寻找合适的内存，避免频繁的系统调用。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

- malloc 通过 **`mmap()`** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

#### 3.3.9 为什么不直接只用mmap或只用brk？ 

- brk会创建内存池，释放的内存不会立马还给操作系统。如果新申请的内存很大，内存池中空闲内存无法满足，只能再去向操作系统申请（操作系统以为内存池中的内存都是在使用的），这样频繁的调用和释放会导致越来越多的**<font color='red'>内存碎片</font>**。

- mmap每次释放都会把内存还给操作系统，那么每次申请都会指向mmap系统调用，导致**<font color='red'>频繁的运行态切换</font>**。同时，申请一次虚拟内存需要进行缺页中断才会和物理内存映射，也会**<font color='red'>导致频繁的缺页中断</font>**。

  > 而brk下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。

malloc 实现中，充分考虑了 brk 和 mmap 行为上的差异及优缺点，默认**分配大块内存 (128KB) 才使用 mmap 分配内存空间**。

#### 3.3.10 allocator是什么？

`allocator`也是用于内存分配和释放的方法，与new/delete不同的是，它**<font color='cornflowerblue'>将内存的分配/销毁和构造/析构函数的调用分开了</font>**。

`allocator` 是一种模板类，定义在 `<memory>` 头文件中，基本功能：

- **分配内存**：`allocator` 提供了 `allocate` 方法，用于分配指定大小的内存。
- **释放内存**：`allocator` 提供了 `deallocate` 方法，用于释放之前分配的内存。
- **构造和析构对象**：`allocator` 提供了 `construct` 和 `destroy` 方法，用于在分配的内存上构造和析构对象（在 C++11 及之后的版本，这些方法已被移除，改为使用直接构造和析构）。

#### 3.3.11 malloc、realloc、calloc的区别？

- malloc：分配指定大小的内存块

  ```cpp
  void* malloc(size_t size);
  ```

- calloc：分配指定元素数目和每个元素大小的内存块，并将所分配内存区域的字节全部置为0

  ```cpp
  void* calloc(size_t num, size_t size);
  ```

- relloc：调整已分配内存块的大小，一般用于扩容

  ```cpp
  void* realloc(void *p, size_t new_size);
  ```

### 3.4 大小端字节序

#### 3.4.1 什么是大端模式和小端模式？

对于多字节数据，“大端模式”和“小端模式”是指数据在内存中的存储数据模式。

- **<font color='cornflowerblue'>大端模式</font>**：数据的**<font color='cornflowerblue'>高字节</font>**存储在内存的**<font color='cornflowerblue'>低地址</font>**中；
- **<font color='cornflowerblue'>小端模式</font>**：数据的**<font color='cornflowerblue'>低字节</font>**存储在内存的**<font color='cornflowerblue'>低地址</font>**中。

![如何判断CPU是大端还是小端模式 - Mlib - CSDN博客](G:\code\study\CppStudy\docs\figures\大小端.png)

> 多字节数据，一般靠左边的是高位字节、靠右边的是低位字节。以10进制数字为例：102中，1是最高位，2是最低位

一般来说**在操作系统中常用小端模式，而在网络通信中常用大端模式**（所以网络传输前一般需要进行字节序转换）。

#### 3.4.2 如何用代码判断大小端？

- **方法一：强制类型转换**

  占用字节数更多类型的变量强制转换成字节数更低的类型，查看截断之后剩下的字节部分，截断后会保留**<font color='cornflowerblue'>低地址部分</font>**。

  ```c++
  short a = 0x1234;  // 16位的整型变量，占2个字节（2×8=16）（4个十六进制数字组成，每个十六进制数字占4个bit）
  				   // 高字节：12，低字节：34
  
  char c = (char) (a);		        // 强制类型转换为char，占1个字节，保留低地址的那个字节
  
  if (c == 0x12) {		        	// 低地址的字节是0x12，高字节，说明是大端模式
  	cout << "大端模式" << endl;
  } else if (c == 0x34) {
      cout << "小端模式" >> endl;	  	 // 低地址的字节是低字节，小端模式
  }
  
  ```

- **方法二：利用union联合体**

  利用union联合体实际上是**<font color='cornflowerblue'>共用一块内存的特性</font>**，让union中存在占用字节一个大一个小，判断小的值属于高字节还是低字节（小的使用的是低地址）。

  ```c++
  union endian {
  	shot a;
  	char ch;
  };
  
  endian value;
  value.a = 0x1234;
  
  if (value.ch == 0x12) {		        	// 低地址的字节是0x12，高字节，说明是大端模式
  	cout << "大端模式" << endl;
  } else if (value.ch == 0x34) {
      cout << "小端模式" >> endl;	  	 // 低地址的字节是低字节，小端模式
  }
  ```


### 3.5 内存泄漏相关

#### 3.5.1 什么是内存泄漏？如何产生的？

内存泄漏（Memory Leak）是指程序在运行时动态分配内存后，**<font color='cornflowerblue'>未能正确释放或释放的内存无法再被访问</font>**，从而导致内存资源的浪费。会导致程序使用的内存逐渐增加，可能最终导致程序或系统运行缓慢、崩溃，或无法继续分配更多的内存。

常见的产生内存泄露的原因：

- 使用malloc或者new动态分配的内存，没有对应地使用free或delete释放；
- 在未释放指向地址的内存时，就更改了指针指向，使得没有任何指针指向该内存；
- 没有将基类的析构函数置为虚函数，使用基类指针指向子类对象时，释放资源时无法执行子类的析构函数；

#### 3.5.2 如何排查内存泄漏？ 如何预防？

- **工具和库**：使用工具来检测内存泄漏，例如：
  - **Valgrind**：Linux一个强大的工具，用于检测内存泄漏和其他内存相关问题。
  - **AddressSanitizer**：一个内存错误检测工具，集成在GCC和Clang中。
  - **CRT库**：C运行时库，可以用来调试堆函数。
  - **Visual Studio**：包含内置的内存泄漏检测功能。

- **使用智能指针**：在C++中使用智能指针（如`std::unique_ptr`和`std::shared_ptr`）
- **良好的编程习惯**：配套使用new/delete、mallc/free，基类的析构函数置为虚函数等



### 3.6 对象复用与零拷贝

#### 3.6.1 对象复用

对象复用是指在程序中重复使用已经分配的对象，而不是每次都创建新的对象。即所谓的**<font color='cornflowerblue'>”池式结构“</font>**。这种做法有助于减少内存分配和释放的开销，优化性能。

对象复用是遵循了一种设计模式：**<font color='cornflowerblue'>Flyweight享元模式</font>**，是设计模式中的一种结构型模式，旨在通过共享尽量多的对象来最小化内存使用。

常见例子：线程池、连接池、内存池。

#### 3.6.2 零拷贝

零拷贝（Zero Copy）是一种技术，通过**<font color='cornflowerblue'>减少数据在内存中的复制次数来优化程序的性能</font>**，尤其是在进行大量数据传输时，如网络通信、文件I/O等场景中。零拷贝技术可以显著降低CPU占用率，提高数据传输速度，因为它避免了传统方法中多次数据复制的开销。

常见的例子：

- mmap：将文件映射到用户地址空间，避免了从内核空间向用户空间的数据拷贝；
- vector中的emplace_back()：与push_back()相比，其在传输参数时是直接利用相应的参数构造函数构造，而不是通过拷贝；



## 4. C++面向对象

### 4.1 struct和class的异同？

**相同点：**

- 都是用来对数据和操作方法的封装，包含成员变量和成员函数；
- 都可以继承来实现变量和方法的复用，有访问控制机制，操作几乎一致；

**不同点：**

- 默认访问控制不同：struct中默认为public，class默认是private的；
- 默认继承访问控制不同：struct默认为public继承，class默认private继承。
- 实际使用中，常通过struct来定义简单的数据结构，class用于表示更加复杂的对象。

### 4.2 C语言和C++中struct的区别？

- C语言中struct只是一些变量的集合体，只有变量，不能有函数；C++中的struct不仅可以包含成员变量，还可以包含成员函数；

- C语言中的struct没有访问控制，无法隐藏数据；C++中的struct具有访问控制，默认为public；

- C语言中的struct没有不支持继承、多态，没有面向对象的概念；C++中的struct与class等价，支持继承和多态。

- C语言中定义的sturct在使用时必须带上struct关键字（除非使用typdef取别名）；C++不需要，可以直接使用名称。

  ```c++
  // C语言
  struct MyStruct {
      int x;
  };
  
  struct MyStruct s;  // 必须使用struct关键字
  
  // C++
  struct MyStruct {
      int x;
  };
  
  MyStruct s;  // 不需要使用struct关键字
  ```

### 4.3 C++中重载、重写和隐藏的区别？

- **重载（overload）**

  重载是指**<font color='cornflowerblue'>函数名相同，但参数类型、个数不同</font>**的函数之间是重载关系。不能通过返回值不同来重载函数。编译器会根据调用函数时输入的参数去执行最为匹配的那个函数。重载是实现**<font color='red'>编译期多态</font>**的方法。

- **重写（override）**

  重写是指在**<font color='cornflowerblue'>子类中重新实现父类中定义的虚函数</font>**，要求函数名称、输入参数和返回值均一致，且必须是**虚函数**。重写是实现**<font color='red'>运行期多态</font>**的方法。

- **隐藏（hide）**

  隐藏是指子类中的函数屏蔽了父类中的同名函数。

  - 如果子类和父类的同名函数参数一致，和重写类似，和重写唯一的区别是这个函数应该是**<font color='cornflowerblue'>非虚函数</font>**；
  - 如果参数不一致，无论父类中函数**<font color='cornflowerblue'>是否是虚函数，都会被隐藏</font>**。

### 4.4 构造函数相关

#### 4.4.1 C++中有哪几种构造函数？

- **默认构造函数**：无需参数的构造函数，如果程序员**没有定义任何构造函数**，编译器会自动生成一个默认构造函数；
- **含参构造函数**：接收一个或多个参数的构造函数；
- **拷贝构造函数**：接收同类对象的引用作为参数的构造函数，能够复制该对象的内容创建新的对象；
- **移动构造函数**（C++ 11引入）：接收同类对象的右值引用作为参数的构造函数，用于**<font color='cornflowerblue'>将源对象的资源移动给新对象</font>**，而不是类似拷贝构造函数的复制资源；
- **委托构造函数**（C++ 11引入）：指在一个构造函数的**<font color='cornflowerblue'>初始化列表中调用同一个类的另一个构造函数</font>**；
- **转换构造函数**：只接收一个其他类型的参数，将其他类型转换为本类的对象。（可以理解为特殊的拷贝构造函数）

#### 4.4.2 什么情况会调用拷贝构造函数？

- 用类的一个实例对象去**初始化**另一个对象的时候；
- 函数的**输入参数**是类的实例对象且是**值传递**时，会拷贝构造局部副本；
- 函数的**返回值**是函数体内局部的类的实例对象且是**值传递**时。

#### 4.4.3 类成员的初始化方式有哪些？

**赋值初始化**：

- 在构造函数的函数体内进行赋值初始化；
- 是**<font color='red'>在所有成员变量已经被分配内存后才进行的</font>**，因此不适用于常量、引用等。

**列表初始化**：

- 在构造函数名：后面通过初始化列表进行初始化；
- 在成员变量**<font color='red'>分配内存时就进行初始化</font>**，构造函数的函数体尚未执行；
- 初始化顺序是由变量的声明顺序决定的，而不是初始化列表中的顺序决定的；
- 列表初始化的执行时机是由编译器实现的，一定在用户代码之前。

#### 4.4.4 哪些成员变量必须使用列表初始化的情况？

- const类型变量；
- 引用类型变量；
- 若基类没有默认构造函数，需要在子类构造函数的初始化列表中手动执行基类的含参构造函数；
- 成员变量是一个类的对象，且该类没有默认构造函数。

#### 4.4.5 为什么列表初始化更快？

- 列表初始化是直接调用对应的构造函数进行构造；

- 不使用初始化列表时，由于是先分配内存，后面再赋值的过程。所以会：**先调用一次默认构造函数、然后调用相应的构造函数构造一个临时变量、使用临时变量赋值成员变量，析构掉临时变量**。所以比较慢。

  <img src="G:\code\study\CppStudy\docs\figures\非初始化列表的情况.png" alt="在这里插入图片描述" style="zoom:80%;" />

#### 4.4.6 构造函数的执行顺序？

1. 虚基类的构造函数；
2. 基类的构造函数；
3. 成员变量是类对象的构造函数；
4. 当前类本身的构造函数。

> **析构函数顺序相反**

#### 4.4.7 编译器会为生成哪些函数？ 什么情况下会生成这些函数？

- **默认构造函数**：当用户没有定义任何构造函数时；
- **默认拷贝构造函数**：当用户没有定义拷贝构造函数时，是**<font color='red'>浅拷贝</font>**；
- **默认移动构造函数（C++11引入）**：当用户没有定义移动构造函数时；
- **默认析构函数**：当用户没有定义析构函数时；
- **默认拷贝赋值操作符**：当用户没有定义赋值操作符时，是**<font color='red'>浅拷贝</font>**；
- **默认移动赋值操作符**：没有定义移动赋值操作符时。

除了上述情况，当**<font color='cornflowerblue'>对某个函数使用 `= default`关键字时，显式地指定让编译器默认生成</font>**。

相反，**<font color='cornflowerblue'>将函数标记为 `= delete`，那么编译器不会生成对应的函数，也就无法使用</font>**。

### 4.5 面向对象的三大特性

#### 4.5.1 什么是封装、继承、多态？

- **封装**：是指将对象的内部实现细节隐藏起来，只对外部暴露必要的接口，并提供访问控制（private、protected、public），这种机制增强了数据的安全性，保证外部代码无法直接访问私有成员，同时简化了代码的维护和使用。
- **继承**：是指一个新类（通常称为子类、派生类）从现有的类（称为父类、基类）中继承属性和方法的过程，能够使代码更加模块化、可重用、易于维护。同时，子类对象可以当作父类对象使用。
- **多态**：是指同一个操作可以作用于不同的对象，产生不同的行为，程序可以根据上下文动态地选择具体实现，提高了代码的灵活性和可扩展性，多态又分为编译期多态（函数重载、运算符重载）和运行期多态（虚函数）。

#### 4.5.2 除了继承外，C++中类之间还存在什么关系？

- **组合**：一种“拥有”关系，表示一个类由多个其他类的对象组成（也就是其他类的对象作为一个类的成员变量），组合类负责其成员对象的创建和销毁。

  ```c++
  class Engine {
  public:
      void start() {
          std::cout << "Engine started" << std::endl;
      }
  };
  
  class Car {
  private:
      Engine engine;  // Car 拥有一个 Engine 对象
  
  public:
      void start() {
          engine.start();  // 使用 Engine 的方法
          std::cout << "Car started" << std::endl;
      }
  };
  ```

- **聚合**：一种较弱的“拥有”关系，聚合关系中的部分对象的生命周期不由整体类管理，部分对象可以在整体类之外创建和销毁（例如通过指针实现）。

  ```c++
  class Car {
  private:
      Engine* engine;  // Car 持有一个 Engine 对象的指针
  
  public:
      Car(Engine* eng) : engine(eng) {}  // 通过外部传入的 Engine 对象初始化
  
      void start() {
          engine->start();
          std::cout << "Car started" << std::endl;
      }
  };
  ```

- **关联**：表示一个类知道另一个类，并与之互动，既不表示“整体-部分”的关系，也不表示“拥有”关系。

  ```c++
  class Teacher;  // 前向声明
  
  class Student {
  private:
      Teacher* teacher;  // 单向关联，Student 知道 Teacher
  
  public:
      void setTeacher(Teacher* t) {
          teacher = t;
      }
  };
  
  class Teacher {
  private:
      Student* student;  // 双向关联，Teacher 也知道 Student
  
  public:
      void setStudent(Student* s) {
          student = s;
      }
  };
  ```

- **依赖**：一个类使用另一个类的一些功能或服务，通常通过类中的某个成员函数来体现。依赖关系是临时的，类之间的这种关系通常比较短暂。

  ```c++
  class Engine {
  public:
      void start() {
          std::cout << "Engine started" << std::endl;
      }
  };
  
  class Car {
  public:
      void drive(Engine& engine) {  // Car 依赖于 Engine 对象
          engine.start();
          std::cout << "Car is driving" << std::enl;
      }
  };
  ```

#### 4.5.3 与继承相比，组合有什么优缺点？

**继承的优缺点**：

- 优点：
  - 代码重用：子类直接继承父类的属性和方法；
  - 逻辑层次清晰：可以建立清晰的层次结构；
  - 多态性：继承支持多态，父类指针可以指向子类，实现运行时动态绑定。
- 缺点：
  - 强耦合：子类和父类之间存在强耦合关系，子类依赖于父类的实现细节，当父类发生变化时，子类可能需要相应地修改；
  - 脆弱基类问题：当一个父类被多个子类继承，基类的任何改动都会影响所有子类，代码难以维护；
  - 静态继承：继承关系在编译期就确定下来了，无法在运行时后改变继承。

**组合的优缺点**：

- 优点：
  - 当前对象只能通过所包含的对象去调用其方法，内部细节是不可见的，符合封装特性；
  - 松耦合关系：修改所包含类的代码不需要修改当前对象类的代码；
  - 动态组合：可以在运行时通过替换组合对象，轻松改变组合类的行为；
- 缺点：
  - 容易造成大量的对象；
  - 需要对接口仔细地定义，才能组合多个对象，代码重用性低。



### 4.5 类的大小





## 5. C++ STL（标准模板库）

### 5.1 String

#### 5.1.1 C++新增了String类，它与char  *有什么区别吗？  底层实现？

Strng是一种动态的字符串类，实际上是对char *的一种**封装**，他有三个关键数据组成：

- 指向字符串数据的指针：`char*`
- 当前字符串的**长度**（size）：`size_t`
- 字符串的最大**容量**（capacity）：`size_t` ，若超出则会动态扩容

`std::string`通过**动态分配内存和**使用诸如拷贝控制（**复制构造、赋值操作符**）来管理字符串的生命周期和内存使用，提供了更多的功能（一些函数和操作符，如find、substr，+）和安全性。当需要扩展字符串时，`std::string`会**<font color='cornflowerblue'>自动分配更大的内存块（一般是两倍大小），并将原字符串的内容复制到新内存中</font>**。

**安全性的体现**：

- **`char *`**：由于没有边界检查，C风格字符串操作容易导致缓冲区溢出等安全问题。
- **`std::string`**：`std::string`的所有操作都有边界检查，能有效避免常见的缓冲区溢出问题。

#### 5.1.2 String所占用的内存分析？

String所占用的内存可以分为两个部分：<font color='cornflowerblue'>**std::string对象本身** </font>+ **<font color='cornflowerblue'>字符数据</font>**

- **std::string 对象本身（64位系统）：**
  - 8字节的指针（用于存储字符数据）
  - 8字节的长度
  - 8字节的容量

- **字符数据：**
  - 字符串内容 "Hello, world!" 的长度是13个字符，加上一个空字符，总共14个字符，即占用14个字节。可能包括额外的内存对齐开销，但这些开销由内存分配器处理，通常不会对字符数据本身造成明显影响。

> **小字符串优化（SSO）**
>
> `std::string`实现了小字符串优化，短字符串的数据会直接存储在`std::string`对象内部，而不是额外分配内存。

