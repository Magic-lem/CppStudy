# 一、C++语言基础

## 1. 基本语法

### 1.1 指针和引用相关

#### 1.1.1 指针和引用的区别？

- **指针**是一个变量，其指向一个地址，本身也占用内存；**引用**只是个原变量别名，本身不占用内存。
- **指针**可以为空，并且可以改变指向；而**引用**必须初始化且不能再改变。
- `sizeof`函数作用于**指针**会获得指针的大小；作用于**引用**会获得原变量的尺寸。
- **指针**作为参数传递时，也会拷贝一个形参副本，指向同一个内存区域，修改这个副本指针不会影响到原指针；而**引用**传参只是拷贝了一个别名，修改后会影响原始变量。
- **指针**可以有多级，即存在指向指针的指针；而**引用**只能有一级。

#### 1.1.2 参数传递时什么时候该用指针，什么时候该用引用？ 什么时候值传递？

|              | 只使用传递过来的值，而不对值进行修改 | 需要修改传递过来的值 |
| ------------ | ------------------------------------ | -------------------- |
| 内置数据类型 | 按值传递（小型结构）                 | 指针传递             |
| 数组         | 指针传递                             | 指针传递             |
| 结构         | 指针或引用（较大的结构）             | 指针或引用           |
| 类、对象     | 引用传递                             | 引用传递             |

- 值传递拷贝的数据就是传递的**<font color='cornflowerblue'>变量的值（传递值）</font>**，当变量较大时效率会比较慢；
- 指针传递拷贝的数据是**<font color='cornflowerblue'>指针变量的值（传递值）</font>**，固定的4字节（32位系统）或8字节（64位系统）；
- 引用传递拷贝的数据是**<font color='cornflowerblue'>变量的地址（传递地址）</font>**，固定的4字节（32位系统）或8字节（64位系统），为这个地址创建别名；
- 需要返回函数内部局部变量的内存时用**指针传递**，返回局部变量的引用是无意义的（这个局部变量在函数作用域结束后会销毁）；
- 对栈空间比较敏感（如递归）时使用**引用传递**，不需要创建临时变量，开销更小；
- 类对象作为参数传递时用**引用传递**，避免由于拷贝构造副本带来的开销（标准方式）。

#### 1.1.3 引用的底层实现？



#### 1.1.4 一个指针占用多少内存？

- 在32位系统中，占用4字节；

- 在64位系统中，占用8字节。


#### 1.1.5 常量指针和指针常量的区别？

- **常量指针（`const int *`）**：是底层常量，可以改变指针的指向，但不能通过指针改变指向对象的值；
- **指针常量（`int * const`）**：是顶层常量，不可以改变指针的指向，但可以通过指针改变指向对象的值。

#### 1.1.6 函数指针和指针函数的区别？

- **函数指针**：是一个指向函数的指针，该指针指向函数的地址（代码段），通过这个指针可以调用这个函数；由于指针可以动态地调整指向的函数地址，因此**<font color='cornflowerblue'>函数指针是实现运行时多态的基础（如虚函数指针）</font>**。

  ```c++
  // 例：
  int add(int a, float b) {
      return a + static_cast<int>(b);
  }
  
  // 函数指针
  int (*func_ptr)(int, float) = &add;
  ```

- **指针函数**：是一个函数，返回值是某个类型的指针。

  ```c++
  int* function_name(parameters);
  ```

#### 1.1.7 数组名和指针的区别？

对于如下的数组名`a`和指向数组的指针`p`：

```cpp
int a[10];	
int (*p)[10] = &a;  // &a取地址
```

- `a`作为数组名，实际上等价于`&a[0]`，即**数组中第一个元素`a[0]`的地址<font color='red'>（可以理解为一种指针常量的作用，但不是指针）</font>**，无法修改其指向等。可以通过`a[i]`访问数组元素并修改，但是不能对`a`进行赋值操作；且对a进行取地址是对数组的第一个元素取地址，而不是指针地址；`sizeof`获得的是数组的大小。
- `p`是真正的指针，指向数组`a`的地址。可以通过`*p`（解引用）来获得数组`a`（即数组本身 `int[10]`，不是地址）。通过`(*p)[i]`等价于`a[i]`访问数组元素，等价于 `a[i]`。且可以改变指向。`sizeof`获得的指针的大小。
- **数组名用于形参传递时，一般会退化成指向数组的指针**。

#### 1.1.8 野指针和悬空指针

- **野指针**：没有被初始化的指针；

  解决方案：编译器在指针定义时默认将其初始化为nullptr，如果直接使用编译器会报错。

- **悬空指针**：指针指向的内存已经被释放；

  解决方案：及时销毁或置空指针；使用智能指针。







### 1.2 常见的关键字

#### 1.2.1 const关键字的作用？

`const`主要用来定义常量和保护变量不被修改：

- **定义常量**：使用`const`可以定义一个不可修改的常量，**`const`常量的默认链接方式是内部链接（只有该源文件可见）**，可以将其定义在头文件中而不会引起重复定义问题，每个包含该头文件的源文件都各自拥有一个`const`常量的副本。

  ```cpp
  // constants.h
  const int MAX_VALUE = 100;
  ```

- **修饰变量/成员变量**：用`const`修饰一个变量，阻止这个变量被改变，在定义变量时必须初始化。

  ```cpp
  // 变量
  const int value;
  
  // 成员变量
  class MyClass {
  public:
      MyClass(int v) : value(v) {}
      void printValue() const {
          std::cout << value << std::endl;
      }
  private:
      const int value;
  };
  
  ```

- **修饰函数参数**：用`const`修饰一个函数的参数，表示在函数内部不能修改这个参数，一般搭配引用或指针使用。

  ```cpp
  void printValue(const int value) {
      // value不能在函数内部被修改
      printf("%d\n", value);
  }
  ```

- **修饰指针变量**：`const`也可以修饰指针变量，分为：常量指针和指针常量。

  ```cpp
  const int* value;	// 常量指针，value可以改变指向，，但不能改变所指向地址的变量值，底层const
  int* const value;	// 指针常量，可以改变指向地址的变量值，但不能改变指向，顶层const
  ```

- **修饰返回值**：表示返回的值不能修改，通常用于返回引用类型。

  ```cpp
  class MyClass {
  public:
      const int& getValue() const {
          return value;
      }
  private:
      int value;
  };
  ```

- **修饰类成员函数**：表示该成员函数不能修改类的成员变量，显式用`mutable`修饰的除外。

#### 1.2.2 constexpr和const的区别？

常量又分为**编译期常量**和**运行期常量**。编译期常量，要求变量的值必须**在编译时就能确定**，而运行期常量是在程序运行期间可以**通过计算得出的常量**。编译期常量使得C++程序能够在编译阶段执行更多的计算，带来性能优化、安全性等好处。

C++ 11之前，**这两个都是由`const`来定义**，由编译器决定const修饰的变量是编译期常量还是运行期常量。为了能够显式地指定是编译期常量，C++ 11 中引入了常量表达式`constexpr`来定义编译期常量。它和`const`之间的区别：具体来说：

- `const`既可以定义编译期常量也可以定义运行期常量，`constexpr`来定义编译期常量；
- `constexpr`需要确保变量和函数**在编译期计算出结果**，编译器会对其严格检查，如果无法在编译期确定该值，则会报错；
- **`constexpr`函数**在编译时执行，并且其参数必须是常量表达式，返回值也必须是常量表达式，且内部被要求是非常简单，如只有一个return语句（C++11)；
- 对于类的构造函数，不能是`const`的（因为要构造对象，会修改对象状态），但是可以是`constexpr`的，要求**函数体只能包含可在编译时执行的语句，所有的成员变量初始化必须在初始化列表中进行，参数也必须是编译时常量（`constexpr`）**。

#### 1.2.3 static关键字的作用？

`static`关键字主要用于控制变量的**生命周期**、**作用域**以及**访问权限**。

- **修饰局部变量**：可以让局部变量的**生命周期持续到程序结束**，不会随着函数的结束而销毁，但是作用域仍然局限于定义它的函数内部，可以用于多次执行一个函数时保存变量值等。
- **修饰全局变量和全局函数**：限制它们的**作用域为定义它们的源文件**，防止它们在其他源文件中被调用。
- **修饰类成员变量**：该成员变量属于类而不属于任何一个对象，因此也需要**在类外部定义**。
- **修饰类成员函数**：函数属于类而不属于对象，可以在没有实例时调用，但**只能访问类内的静态成员变量**。

#### 1.2.4 volatile关键字的作用？

`volatile`指易变的，表示变量可能在任何时候被外部因素修改，**编译器不应该对该变量的访问进行优化（不添加到缓存中，每次从内存中读取）**。在多线程编程中，`volatile`可以用于修饰共享变量，确保一个线程对变量的修改能被另一个线程立即看到。

#### 1.2.5 extern关键字的作用？

`extern`的作用主要为声明外部变量（全局变量、函数），告诉编译器这个变量或函数是**在其他文件中定义的，并且在当前文件中可以使用**。使用 `extern` 关键字可以帮助在多个源文件之间共享变量或函数，而不需要在每个文件中重复定义。

除此之外，在C++中引用C语言的代码时，需要告诉编译器按照 C 的链接规则处理这些函数，则需要通过 `extern "C"`来实现**，当在 C++ 代码中声明或定义 C 函数时，需要将函数声明放在 `extern "C"` 块中**。

#### 1.2.6 #define和typedef的区别？

它们都可以**用来创建别名**，但它们的用途和机制有很大不同。

- **处理阶段不同**：`#define`是预处理指令，在预处理阶段起作用；`typedef`是一个关键字，在编译阶段处理；
- **使用目的不同**：`#define`常用于定义常量、宏函数，在编译之前进行文本替换，还可以用于条件编译防止头文件重复定义；`typedef`主要用于创建现有复杂类型的别名，使得代码更加简化和具有可读性；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；`typedef`在编译时会进行类型检查；

#### 1.2.7 都能定义常量，#define和const的区别？

`#define` 和 `const` 都可以用来定义常量，但它们在使用方式、语法、作用域和编译时的处理上有很大的不同。以下是它们的主要区别：

- **处理阶段不同**：`#define`是预处理指令，在预处理阶段起作用；`const` 是一个关键字，在编译阶段处理；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；`const` 在编译时会进行类型检查，可以在编译时捕捉到类型相关的错误；
- **是否占用内存**：`#define`定义的常量是直接替换为了对应文本，不会占用内存；`const` 定义的常量会存在内存的常量区中，需要内存空间。

#### 1.2.8 #define和函数的区别？

`#define`宏和函数都**用于代码的重用**，允许定义一段代码然后再多个地方使用。它们的区别：

- **处理阶段不同**：`#define`是预处理器指令，在预处理阶段完成替换；函数是经过编译器编译生成可执行代码并链接，在运行时跳转到具体调用函数；
- **处理方式不同**：`#define`是直接文本替换，不存在函数调用，无需返回值；函数则需要跳转到具体调用位置执行，有返回值；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；函数在编译时会进行类型检查；

#### 1.2.8 #define和内联函数的区别？

`#define`宏和内联函数都**用于代码的重用**，允许定义一段代码然后再多个地方使用。它们的区别可以参考【#define和函数的区别】。

**需要多注意的是**：内联函数也不会产生函数调用的开销，而是通过**直接把函数代码嵌入到执行内联函数的位置**。

#### 1.2.10 override关键字和final关键字的作用？

- **override 关键字**

  当需要在子类中重写父类的**<font color='cornflowerblue'>虚函数（必须是虚函数）</font>**时，可以在后面加上override关键字，显式地指定这是重写的方法，例如：

  ```c++
  class A {
  public:
  	virtual void foo();		// 虚函数
  };
  
  class B: public A {
  public:
  	void foo() override;	// 继承自A重写的方法
  };
  ```

- **final 关键字**

  当**<font color='cornflowerblue'>不希望类被继承或类中的某个虚函数被重写</font>**，可以在类名或虚函数后面添加final关键字，表示不能被继承或重写，例如：

  ```c++
  class A {
  public:
  	virtual void foo() final;		// 虚函数
  };
  
  class B final: public A {	// 类B使用了final修饰
  public:
  	void foo() override;	// 继承自A重写的方法，会报错，因为A中通过final关键字表明这个函数不能被重写
  };
  
  class C: B {				// 报错，B不能被继承
      
  };
  ```

#### 1.2.11 mutable关键字的作用？

对于被const修饰的成员函数，它不能修改成员变量的值，除非**使用mutable关键字修饰这个成员变量**。意味着这个成员变量是**可以被const成员函数修改的**。

#### 1.2.12 explicit关键字的作用？

explicit关键字用于修饰类的构造函数，意味着禁止发生相应的隐式类型变换，只能显式的方式进行类型转换，注意：

- explicit只能用于类的构造函数声明上；
- explicit作用于单个参数的构造函数上（即转换构造函数），因为涉及到类型转换；
- 被explicit修饰构造函数的类，不能够发生相应的隐式类型转换。

```cpp
class MyClass {
public:
    explicit MyClass(int x) {
        // 转换构造函数
    }
};

int main() {
    MyClass obj1 = 10;    // 错误：由于 explicit，不能进行隐式转换
    MyClass obj2(10);     // 正确：显式调用转换构造函数
    return 0;
}

```



### 1.3 数据类型和内存大小

|   类型    |  32位  |  64位  |
| :-------: | :----: | :----: |
|   char    | 1 字节 | 1 字节 |
|   short   | 2 字节 | 2 字节 |
|    int    | 4 字节 | 4 字节 |
|   float   | 4 字节 | 4 字节 |
|  double   | 8 字节 | 8 字节 |
|   long    | 4 字节 | 8 字节 |
| long long | 8 字节 | 8 字节 |
|   指针    | 4 字节 | 8 字节 |

### 1.4 字符串相关

#### 1.4.1 strlen和sizeof的区别？

- strlen是处理字符的**库函数**；sizeof是C++**运算符**，并不是函数，结果**在编译器获得**。
- strlen只能用于C风格字符串（以`'\0'`表示结尾）；sizeof可以用于任意数据的类型或数据本身。
- sizeof是在编译器获取结果，因此无法获取在运行期动态分配的空间大小；



### 1.5 C++异常处理

常见的异常：

- 数组下标越界；
- 除法计算时除数为0；
- 动态分配内存时空间不足；
- ...

#### 1.5.1 try、throw和catch关键字

C++主要的异常处理机制，`try`、`throw`和`catch`关键字的搭配使用，例：

```c++
double m = 1, n = 0;
try {
	if (n == 0) throw -1;  // 抛出int异常
	else if (m == 0) throw -1.0; // 抛出double异常
	else cout << m / n << endl;
}
catch (double d) {	// 捕获double类型异常
	cout << "catch double" << d << endl;
}
catch (int i) {		// 捕获int类型异常
	cout << "catch int" << i << endl;
}
catch (...) {		// 捕获所有类型异常，不推荐
    cout << "catch all" << endl;
}
```

#### 1.5.2 函数的异常声明列表

在定义函数时，提前指出函数所能抛出异常类型的列表，例如：

```c++
int fun() throw(int,double){...}
```

上述代码表明fun函数**可能会抛出int或double类型的异常**。如果`throw()`中为空，说明不会抛出任何异常。如果不加`throw`则是可以抛出所有异常。编译器可以根据 `throw` 列表做出一些优化，比如减少异常处理相关的开销（但实际效果可能依赖具体编译器），调用者可以更好地理解函数的行为，从而在使用时进行适当的异常处理。

#### 1.5.3 有哪些常见的异常类型？

C++中存在一个标准异常类`exception`，常见的一些异常都是继承自这个类，常见的有：

- `bay_typeid`：使用typeid运算符获取类型信息时，操作对象是多态类的指针，且指向NULL，则会抛出这个异常；
- `bad_cast`：使用dynamic_cast进行基类到派生类的强制转换时，如果不安全，则抛出此异常；
- `bad_alloc`：使用new运算符动态分配内存时，若空间不足，则抛出此异常；
- `out_of_range`：对于容器（vector、string）利用下标访问数据时，下标越界，则抛出此异常。





### 1.x 其他基础内容

#### 1.x.1 变量的定义和声明的区别？

- 声明仅仅是将变量的位置和类型告诉编译器，并不实际为变量分配内存；定义是为变量分配内存空间。
- 相同的变量可以多次声明；但只能定义一次（分配一次内存）。

#### 1.x.2 C++和python的区别？

- C++是**编译型语言**，代码在允许前需要在**特定平台**编译成机器代码，后面就不需要再编译了；Python是**解释型语言**，每次都需要经过翻译和解释过程才可以执行。因此在实际运行中，C++通常具有更高的执行效率和性能，而Python方便跨平台，且开发速度快；
- C++需要**手动管理内存**，这也是C++语言的特色，可以有更高的性能但也容易出现内存泄漏等问题；Python有**自动垃圾回收机制**；
- C++定义变量是**静态类型**，在编译期确定，需要显示声明；Python变量是**动态类型**，在运行时确定，无需显式声明；
- C++适合系统编程、实时系统和高性能计算等需要高效的场景；Python适合Web开发、数据科学、机器学习、自动化脚本等设计开发。

#### 1.x.3 C++和JAVA的区别？

- C++是**编译型语言**，代码在允许前需要在**特定平台**编译成机器代码，后面就不需要再编译了；JAVA是**解释型语言**，需要编译成字节码，然后再JAVA虚拟机(JVM)上解释执行，可移植性更强；
- C++需要**手动管理内存**，这也是C++语言的特色，可以有更高的性能但也容易出现内存泄漏等问题；JAVA有**自动垃圾回收机制**；
- C++**支持指针**，允许直接操作内存地址；JAVA**不支持指针**，避免了直接对内存的操作，提高了安全性；
- C++既支持**面向过程也支持面向过程**；JAVA几乎所有代码**都是通过类和对象的形式**组织的；
- C++有丰富的标准库和第三方库，但使用起来比较复杂；JAVA拥有**庞大的标准库和第三方库生态系统**（如Spring），使用相对简单；
- C++通过**多继承、抽象类**等方式实现继承和多态；JAVA主要通过**接口**来实现，更加简易。
- C++适合系统编程、实时系统和高性能计算等需要高效的场景；JAVA适合企业级应用开发、Web开发、移动应用开发、分布式系统开发等。

#### 1.x.4 C++中初始化和赋值的区别？

初始化和赋值都涉及**将值分配给变**量，它们的区别在于**发生的时间和操作对象的状态**。特别是在涉及类对象时，初始化和赋值之间的区别更加显著。

- **初始化**是指变量创建时为其分配初始值的过程，发生在对象或变量的生命周期开始时；**赋值**是变量已经存在后，将一个新的值分配给该变量的过程。
- 类对象的**初始化**时通过构造函数来实现的；**赋值**是通过赋值操作符`=`来实现

#### 1.x.5 C++中直接初始化和拷贝初始化的区别？

- **直接初始化**：通过`()`或`{}`进行初始化的一种方式，通常是直接调用构造函数；

  ```c++
  std::string str1("Hello");  // 直接初始化
  int b(10);                  // 直接初始化
  std::string str2{"Hello"};  // 使用列表初始化的直接初始化
  int c{10};                  // 使用列表初始化的直接初始化
  std::string str3(str1);		// 直接初始化，调用拷贝构造函数
  ```

- **拷贝初始化**：使用等号`=`进行初始化的一种方式，通常会调用拷贝构造函数或移动构造函数；如果右侧是与左侧不同类型的表达式，**会发生隐式的类型转换**。

  ```cpp
  std::string str1 = "Hello";  // 拷贝初始化，构建临时对象，然后拷贝，会发生隐式类型转换（字符串字面值const char*->std::string）
  int a = 10;                  // 拷贝初始化，构建临时对象，然后拷贝，不会发生隐式类型转换（int->int）
  std::string str2 = str1;	 // 拷贝初始化，调用拷贝构造函数，不会发生隐式类型转换（string->string）
  ```

> 在现代编译器优化下，拷贝初始化中创建临时对象的过程通常会被优化掉，直接调用构造函数创建对象（**但依然是调用的拷贝构造函数**）。

#### 1.x.6 形参和实参的区别？

- 形参是在函数列出的参数，用于指定函数所需要的输入；实参是用于初始化形参的实际数据。
- 形参只在函数内部有效，在函数被调用时分配内存，函数结束后立刻销毁；实参的作用域是函数调用的上下文。
- 数据传送是单向的，只能把实参的值传输给形参，而不能反向传输。
- 如果形参是引用类型，那么形参只是实参的一个别名，它们访问同一个内存地址，修改形参实参也会发生变化。
- 如果形参是指针类型，它是一个新的指针，但是和实参指向同一个内存地址，修改形参实参不会变化，但修改指向变量的值会同时发生变化。

#### 1.x.7 静态变量什么时候初始化？

静态变量有两种主要类型：**静态全局变量**、**静态局部变量**和**静态成员变量**。它们的初始化规则如下：

- **静态全局变量**：静态全局变量**<font color='cornflowerblue'>在`main`函数执行之前会被初始化（和全局变量一致）</font>**，在程序的全局初始化阶段按照出现顺序初始化；
- **静态局部变量**：初始化时机是当程序第一次调用静态局部变量所在的函数时，即在**<font color='cornflowerblue'>第一次访问时初始化</font>**。

- **静态成员变量**：也是**<font color='cornflowerblue'>在`main`函数执行之前会被初始化</font>**，通常在类定义之外进行定义和初始化。

静态全局变量和静态成员变量的初始化发生在程序的全局初始化阶段，这个阶段是在程序启动时由运行时系统负责完成的，通常称为**静态初始化阶段**。这是为了确保在任何时候访问静态全局变量和静态成员变量时，它们都已经被初始化。

> 对于以上所有的静态变量，如果没有初始值，静态局部变量将被**默认初始化为其类型的零值**。



## 2. 线程安全相关

### 2.1 a++ 和 int a = b 在C++中是否是线程安全的？

不安全。因为这些语句在编译为汇编指令**往往存在多条指令**，而多条指令就意味着可能存在线程安全问题。

```cpp
a++;
// 在汇编语言中存在三条指令：
// 1. 将a的内存值搬运到某个寄存器中
// 2. 将该寄存器中的值自增
// 3. 再将寄存器中的值搬运会a的内存中

int a = b;
// 在汇编语言中存在两条指令：（由于内存之间不能直接搬运，需要借助于寄存器）
// 1. 将b的值搬运到某个寄存器中
// 2. 再从该寄存器中搬运到a的内存地址
```

### 2.2 如何保证它们的原子性？

C++ 11中提供了一个新的原子操作库<atomic>，其中提供了一个模板类：`std::atomic`，可以保证一个变量的操作是原子的。它通过**底层的硬件指令（如 CPU 的原子操作指令）和内存屏障机制来实现原子性**，避免数据竞争（data race）问题。

```cpp
std::atomic<int> counter(0); // 定义一个原子整型变量

// 注意，这里不能用下面语句来定义，因为下面隐式的要调用拷贝构造函数，而std::atomic是利用=delete禁用拷贝构造函数的
std::atomic<int> counter = 0; ❌

// 在下面代码中的自增操作是原子的
void increment() {
    for (int i = 0; i < 1000; ++i) {
        ++counter; // 原子增操作
    }
}
```



## 3. C++内存模型

### 3.2 堆区和栈区

#### 3.2.1 堆区和栈区的区别？

- **申请方式不同**：栈是由系统自动分配和回收，堆需要由程序员显式的申请和回收；
- **大小不同**：栈由高地址向低地址扩展，大小是固定的且较小；堆由低地址向高地址扩展，更大；
- **效率不同**：栈区由系统自动分配，效率很高；堆区的分配效率较慢，且手动管理容易出现内存泄漏或内存碎片；
- **存储内容不同**：在C++中，栈区一般用来存储局部变量、函数参数和返回地址等；堆区用来存储用户动态创建的变量。

#### 3.2.2 堆区和栈区哪个效率更高，为什么？

栈区的效率通常比较高，原因：

- 栈区内存的分配和释放**由编译器自动管理**，内存分配通常是通过调整栈指针来完成，**简单高效**；而堆区的内存分配和释放需要**动态内存分配函数，涉及到包括查找适当大小的空闲块等操作，开销较大**；
- **栈内存是连续的**，局部变量通常紧密排列，符合CPU缓存的访问模式，访问效率高；**堆内存分配的块可能是离散的**，且随着不断的分配和释放**会碎片化**，访问效率降低；
- 栈区由于自动管理不易出错，而堆区容易导致**内存泄漏等问题**，增加了管理复杂性。

#### 3.2.3 浅拷贝和深拷贝的区别

- **浅拷贝**

  只是拷贝出了一个指针，并没有重新申请内存，拷贝的指针和原来的指针指向同一块地址，容易出现对象销毁时多次重复释放资源、悬空指针的问题。

- **深拷贝**

  不止拷贝出一个指针，还会开辟新的内存空间来保存拷贝的资源。每个对象都拥有自己独立的资源，指向不同地址。



### 3.3 动态内存申请

#### 3.3.1 new/delete 和 malloc/free 的异同？

**相同点**：都是用来内存的动态申请和释放

**不同点**：

- new/delete 是C++的运算符；malloc/free 是C/C++的标准库函数
- new可以自动计算要分配的内存大小；malloc必须显式的指定
- new在分配内存失败时会抛出异常，不是返回NULL；malloc分配失败时返回NULL
- new/delete会调用对象的构造函数/析构函数；malloc/free不会
- new/delete返回的是具体类型指针；malloc/free返回的是void *，需要后续的类型转换

#### 3.3.2 既然已经有了malloc/free，为什么需要new/delete？

C++中引入了类和对象，对象创建的时候需要执行**构造函数**，销毁的时候需要调用**析构函数**。malloc/free不具有这个功能，而它们是标准库函数，已经编译了无法轻易地将构造函数和析构函数的功能加上去。因此，提出了new/delete运算符，能够在创建和销毁时去调用构造和析构函数。

#### 3.3.3 new/delete是如何实现的？

**new的实现**：先调用**operator new**标准库函数，分配足够大的原始为类型化的内存，然后运行该类型的构造函数，初始化构造对象，返回指向新分配并构造后对象的指针；

**delete的实现**：先对指向的对象运行析构函数，然后调用**operator delete**标准库函数释放该对象的内存。

#### 3.3.4 被free回收的内存是立刻还给操作系统吗？

不是。会**被ptmalloc使用双链表存起来**，当用户下一次申请内存时，会尝试从这个链表中寻找合适的内存，避免频繁的系统调用。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

### 3.4 大小端字节序

#### 3.4.1 什么是大端模式和小端模式？

对于多字节数据，“大端模式”和“小端模式”是指数据在内存中的存储数据模式。

- **<font color='cornflowerblue'>大端模式</font>**：数据的**<font color='cornflowerblue'>高字节</font>**存储在内存的**<font color='cornflowerblue'>低地址</font>**中；
- **<font color='cornflowerblue'>小端模式</font>**：数据的**<font color='cornflowerblue'>低字节</font>**存储在内存的**<font color='cornflowerblue'>低地址</font>**中。

![如何判断CPU是大端还是小端模式 - Mlib - CSDN博客](G:\code\study\CppStudy\docs\figures\大小端.png)

> 多字节数据，一般靠左边的是高位字节、靠右边的是低位字节。以10进制数字为例：102中，1是最高位，2是最低位

一般来说**在操作系统中常用小端模式，而在网络通信中常用大端模式**（所以网络传输前一般需要进行字节序转换）。

#### 3.4.2 如何用代码判断大小端？

- **方法一：强制类型转换**

  将占用字节数更多类型的变量强制转换成字节数更低的类型，查看截断之后剩下的字节部分，截断后会保留**<font color='cornflowerblue'>低地址部分</font>**。

  ```c++
  short a = 0x1234;  // 16位的整型变量，占2个字节（2×8=16）（4个十六进制数字组成，每个十六进制数字占4个bit）
  				   // 高字节：12，低字节：34
  
  char c = (char) (a);		        // 强制类型转换为char，占1个字节，保留低地址的那个字节
  
  if (c == 0x12) {		        	// 低地址的字节是0x12，高字节，说明是大端模式
  	cout << "大端模式" << endl;
  } else if (c == 0x34) {
      cout << "小端模式" >> endl;	  	 // 低地址的字节是低字节，小端模式
  }
  
  ```

- **方法二：利用union联合体**

  利用union联合体实际上是**<font color='cornflowerblue'>共用一块内存的特性</font>**，让union中存在占用字节一个大一个小，判断小的值属于高字节还是低字节（小的使用的是低地址）。

  ```c++
  union endian {
  	shot a;
  	char ch;
  };
  
  endian value;
  value.a = 0x1234;
  
  if (value.ch == 0x12) {		        	// 低地址的字节是0x12，高字节，说明是大端模式
  	cout << "大端模式" << endl;
  } else if (value.ch == 0x34) {
      cout << "小端模式" >> endl;	  	 // 低地址的字节是低字节，小端模式
  }
  ```

  

## 4. C++面向对象

### 4.1 struct和class的异同？

**相同点：**

- 都是用来对数据和操作方法的封装，包含成员变量和成员函数；
- 都可以继承来实现变量和方法的复用，有访问控制机制，操作几乎一致；

**不同点：**

- 默认访问控制不同：struct中默认为public，class默认是private的；
- 默认继承访问控制不同：struct默认为public继承，class默认private继承。
- 实际使用中，常通过struct来定义简单的数据结构，class用于表示更加复杂的对象。

### 4.2 C语言和C++中struct的区别？

- C语言中struct只是一些变量的集合体，只有变量，不能有函数；C++中的struct不仅可以包含成员变量，还可以包含成员函数；

- C语言中的struct没有访问控制，无法隐藏数据；C++中的struct具有访问控制，默认为public；

- C语言中的struct没有不支持继承、多态，没有面向对象的概念；C++中的struct与class等价，支持继承和多态。

- C语言中定义的sturct在使用时必须带上struct关键字（除非使用typdef取别名）；C++不需要，可以直接使用名称。

  ```c++
  // C语言
  struct MyStruct {
      int x;
  };
  
  struct MyStruct s;  // 必须使用struct关键字
  
  // C++
  struct MyStruct {
      int x;
  };
  
  MyStruct s;  // 不需要使用struct关键字
  ```

### 4.3 C++中重载、重写和隐藏的区别？

- **重载（overload）**

  重载是指**<font color='cornflowerblue'>函数名相同，但参数类型、个数不同</font>**的函数之间是重载关系。不能通过返回值不同来重载函数。编译器会根据调用函数时输入的参数去执行最为匹配的那个函数。重载是实现**<font color='red'>编译期多态</font>**的方法。

- **重写（override）**

  重写是指在**<font color='cornflowerblue'>子类中重新实现父类中定义的虚函数</font>**，要求函数名称、输入参数和返回值均一致，且必须是**虚函数**。重写是实现**<font color='red'>运行期多态</font>**的方法。

- **隐藏（hide）**

  隐藏是指子类中的函数屏蔽了父类中的同名函数。

  - 如果子类和父类的同名函数参数一致，和重写类似，和重写唯一的区别是这个函数应该是**<font color='cornflowerblue'>非虚函数</font>**；
  - 如果参数不一致，无论父类中函数**<font color='cornflowerblue'>是否是虚函数，都会被隐藏</font>**。

### 4.4 构造函数相关

#### 4.4.1 C++中有哪几种构造函数？

- **默认构造函数**：无需参数的构造函数，如果程序员没有定义任何构造函数，编译器会自动生成一个默认构造函数；
- **含参构造函数**：接收一个或多个参数的构造函数；
- **拷贝构造函数**：接收同类对象的引用作为参数的构造函数，能够复制该对象的内容创建新的对象；
- **移动构造函数**（C++ 11引入）：接收同类对象的右值引用作为参数的构造函数，用于**<font color='cornflowerblue'>将源对象的资源移动给新对象</font>**，而不是类似拷贝构造函数的复制资源；
- **委托构造函数**（C++ 11引入）：指在一个构造函数的**<font color='cornflowerblue'>初始化列表中调用同一个类的另一个构造函数</font>**；
- **转换构造函数**：只接收一个其他类型的参数，将其他类型转换为本类的对象。（可以理解为特殊的拷贝构造函数）

#### 4.4.2 什么情况会调用拷贝构造函数？

- 用类的一个实例对象去**初始化**另一个对象的时候；
- 函数的**输入参数**是类的实例对象且是**值传递**时，会拷贝构造局部副本；
- 函数的**返回值**是函数体内局部的类的实例对象且是**值传递**时。

### 4.5 面向对象的三大特性

#### 4.5.1 什么是封装、继承、多态？

- **封装**：是指将对象的内部实现细节隐藏起来，只对外部暴露必要的接口，并提供访问控制（private、protected、public），这种机制增强了数据的安全性，保证外部代码无法直接访问私有成员，同时简化了代码的维护和使用。
- **继承**：是指一个新类（通常称为子类、派生类）从现有的类（称为父类、基类）中继承属性和方法的过程，能够使代码更加模块化、可重用、易于维护。同时，子类对象可以当作父类对象使用。
- **多态**：是指同一个操作可以作用于不同的对象，产生不同的行为，程序可以根据上下文动态地选择具体实现，提高了代码的灵活性和可扩展性，多态又分为编译期多态（函数重载、运算符重载）和运行期多态（虚函数）。

#### 4.5.2 除了继承外，C++中类与类之间还存在什么关系？

- **组合**：一种“拥有”关系，表示一个类由多个其他类的对象组成（也就是其他类的对象作为一个类的成员变量），组合类负责其成员对象的创建和销毁。

  ```c++
  class Engine {
  public:
      void start() {
          std::cout << "Engine started" << std::endl;
      }
  };
  
  class Car {
  private:
      Engine engine;  // Car 拥有一个 Engine 对象
  
  public:
      void start() {
          engine.start();  // 使用 Engine 的方法
          std::cout << "Car started" << std::endl;
      }
  };
  ```

- **聚合**：一种较弱的“拥有”关系，聚合关系中的部分对象的生命周期不由整体类管理，部分对象可以在整体类之外创建和销毁（例如通过指针实现）。

  ```c++
  class Car {
  private:
      Engine* engine;  // Car 持有一个 Engine 对象的指针
  
  public:
      Car(Engine* eng) : engine(eng) {}  // 通过外部传入的 Engine 对象初始化
  
      void start() {
          engine->start();
          std::cout << "Car started" << std::endl;
      }
  };
  ```

- **关联**：表示一个类知道另一个类，并与之互动，既不表示“整体-部分”的关系，也不表示“拥有”关系。

  ```c++
  class Teacher;  // 前向声明
  
  class Student {
  private:
      Teacher* teacher;  // 单向关联，Student 知道 Teacher
  
  public:
      void setTeacher(Teacher* t) {
          teacher = t;
      }
  };
  
  class Teacher {
  private:
      Student* student;  // 双向关联，Teacher 也知道 Student
  
  public:
      void setStudent(Student* s) {
          student = s;
      }
  };
  ```

- **依赖**：一个类使用另一个类的一些功能或服务，通常通过类中的某个成员函数来体现。依赖关系是临时的，类之间的这种关系通常比较短暂。

  ```c++
  class Engine {
  public:
      void start() {
          std::cout << "Engine started" << std::endl;
      }
  };
  
  class Car {
  public:
      void drive(Engine& engine) {  // Car 依赖于 Engine 对象
          engine.start();
          std::cout << "Car is driving" << std::enl;
      }
  };
  ```

#### 4.5.3 与继承相比，组合有什么优缺点？

**继承的优缺点**：

- 优点：
  - 代码重用：子类直接继承父类的属性和方法；
  - 逻辑层次清晰：可以建立清晰的层次结构；
  - 多态性：继承支持多态，父类指针可以指向子类，实现运行时动态绑定。
- 缺点：
  - 强耦合：子类和父类之间存在强耦合关系，子类依赖于父类的实现细节，当父类发生变化时，子类可能需要相应地修改；
  - 脆弱基类问题：当一个父类被多个子类继承，基类的任何改动都会影响所有子类，代码难以维护；
  - 静态继承：继承关系在编译期就确定下来了，无法在运行时后改变继承。

**组合的优缺点**：

- 优点：
  - 当前对象只能通过所包含的对象去调用其方法，内部细节是不可见的，符合封装特性；
  - 松耦合关系：修改所包含类的代码不需要修改当前对象类的代码；
  - 动态组合：可以在运行时通过替换组合对象，轻松改变组合类的行为；
- 缺点：
  - 容易造成大量的对象；
  - 需要对接口仔细地定义，才能组合多个对象，代码重用性低。

