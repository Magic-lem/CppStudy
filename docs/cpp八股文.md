# 一、C++语言基础

## 1. 基本语法

### 1.1 指针和引用相关

#### 1.1.1 指针和引用的区别？

- **指针**是一个变量，其指向一个地址，本身也占用内存；**引用**只是个原变量别名，本身不占用内存。
- **指针**可以为空，并且可以改变指向；而**引用**必须初始化且不能再改变。
- `sizeof`函数作用于**指针**会获得指针的大小；作用于**引用**会获得原变量的尺寸。
- **指针**作为参数传递时，也会拷贝一个形参副本，指向同一个内存区域，修改这个副本指针不会影响到原指针；而**引用**传参只是拷贝了一个别名，修改后会影响原始变量。
- **指针**可以有多级，即存在指向指针的指针；而**引用**只能有一级。

#### 1.1.2 参数传递时什么时候该用指针，什么时候该用引用？

- 需要返回函数内部局部变量的内存时用**指针传递**，返回局部变量的引用是无意义的（这个局部变量在函数作用域结束后会销毁）；
- 对栈空间比较敏感（如递归）时使用**引用传递**，不需要创建临时变量，开销更小；
- 类对象作为参数传递时用**引用传递**，避免由于拷贝构造副本带来的开销（标准方式）。

#### 1.1.3 一个指针占用多少内存？

在32位系统中，占用4字节；

在64位系统中，占用8字节。

#### 1.1.4 常量指针和指针常量的区别？

- **常量指针（`const int *`）**：是底层常量，可以改变指针的指向，但不能通过指针改变指向对象的值；
- **指针常量（`int * const`）**：是顶层常量，不可以改变指针的指向，但可以通过指针改变指向对象的值。

#### 1.1.5 函数指针和指针函数的区别？

- **函数指针**：是一个指向函数的指针，该指针指向函数的地址（代码段），通过这个指针可以调用这个函数；由于指针可以动态地调整指向的函数地址，因此**<font color='cornflowerblue'>函数指针是实现运行时多态的基础（如虚函数指针）</font>**。

  ```c++
  // 例：
  int add(int a, float b) {
      return a + static_cast<int>(b);
  }
  
  // 函数指针
  int (*func_ptr)(int, float) = &add;
  ```

- **指针函数**：是一个函数，返回值是某个类型的指针。

  ```c++
  int* function_name(parameters);
  ```

#### 1.1.6 数组名和指针的区别？

对于如下的数组名`a`和指向数组的指针`p`：

```cpp
int a[10];	
int (*p)[10] = &a;  // &a取地址
```

- `a`作为数组名，实际上等价于`&a[0]`，即**数组中第一个元素`a[0]`的地址<font color='red'>（可以理解为一种指针常量的作用，但不是指针）</font>**，无法修改其指向等。可以通过`a[i]`访问数组元素并修改，但是不能对`a`进行赋值操作；且对a进行取地址是对数组的第一个元素取地址，而不是指针地址；
- `p`是真正的指针，指向数组`a`的地址。可以通过`*p`（解引用）来获得数组`a`（即数组本身 `int[10]`，不是地址）。通过`(*p)[i]`等价于`a[i]`访问数组元素，等价于 `a[i]`。且可以改变指向。







### 1.2 常见的关键字

#### 1.2.1 const关键字的作用？

`const`主要用来定义常量和保护变量不被修改：

- **定义常量**：使用`const`可以定义一个不可修改的常量，**`const`常量的默认链接方式是内部链接（只有该源文件可见）**，可以将其定义在头文件中而不会引起重复定义问题，每个包含该头文件的源文件都各自拥有一个`const`常量的副本。

  ```cpp
  // constants.h
  const int MAX_VALUE = 100;
  ```

- **修饰变量/成员变量**：用`const`修饰一个变量，阻止这个变量被改变，在定义变量时必须初始化。

  ```cpp
  // 变量
  const int value;
  
  // 成员变量
  class MyClass {
  public:
      MyClass(int v) : value(v) {}
      void printValue() const {
          std::cout << value << std::endl;
      }
  private:
      const int value;
  };
  
  ```

- **修饰函数参数**：用`const`修饰一个函数的参数，表示在函数内部不能修改这个参数，一般搭配引用或指针使用。

  ```cpp
  void printValue(const int value) {
      // value不能在函数内部被修改
      printf("%d\n", value);
  }
  ```

- **修饰指针变量**：`const`也可以修饰指针变量，分为：常量指针和指针常量。

  ```cpp
  const int* value;	// 常量指针，value可以改变指向，，但不能改变所指向地址的变量值，底层const
  int* const value;	// 指针常量，可以改变指向地址的变量值，但不能改变指向，顶层const
  ```

- **修饰返回值**：表示返回的值不能修改，通常用于返回引用类型。

  ```cpp
  class MyClass {
  public:
      const int& getValue() const {
          return value;
      }
  private:
      int value;
  };
  ```

- **修饰类成员函数**：表示该成员函数不能修改类的成员变量，显式用`mutable`修饰的除外。

#### 1.2.2 constexpr和const的区别？

常量又分为**编译期常量**和**运行期常量**。编译期常量，要求变量的值必须**在编译时就能确定**，而运行期常量是在程序运行期间可以**通过计算得出的常量**。编译期常量使得C++程序能够在编译阶段执行更多的计算，带来性能优化、安全性等好处。

C++ 11之前，**这两个都是由`const`来定义**，由编译器决定const修饰的变量是编译期常量还是运行期常量。为了能够显式地指定是编译期常量，C++ 11 中引入了常量表达式`constexpr`来定义编译期常量。它和`const`之间的区别：具体来说：

- `const`既可以定义编译期常量也可以定义运行期常量，`constexpr`来定义编译期常量；
- `constexpr`需要确保变量和函数**在编译期计算出结果**，编译器会对其严格检查，如果无法在编译期确定该值，则会报错；
- **`constexpr`函数**在编译时执行，并且其参数必须是常量表达式，返回值也必须是常量表达式，且内部被要求是非常简单，如只有一个return语句（C++11)；
- 对于类的构造函数，不能是`const`的（因为要构造对象，会修改对象状态），但是可以是`constexpr`的，要求**函数体只能包含可在编译时执行的语句，所有的成员变量初始化必须在初始化列表中进行，参数也必须是编译时常量（`constexpr`）**。

#### 1.2.3 static关键字的作用？

`static`关键字主要用于控制变量的**生命周期**、**作用域**以及**访问权限**。

- **修饰局部变量**：可以让局部变量的**生命周期持续到程序结束**，不会随着函数的结束而销毁，但是作用域仍然局限于定义它的函数内部，可以用于多次执行一个函数时保存变量值等。
- **修饰全局变量和全局函数**：限制它们的**作用域为定义它们的源文件**，防止它们在其他源文件中被调用。
- **修饰类成员变量**：该成员变量属于类而不属于任何一个对象，因此也需要**在类外部定义**。
- **修饰类成员函数**：函数属于类而不属于对象，可以在没有实例时调用，但**只能访问类内的静态成员变量**。

#### 1.2.4 volatile关键字的作用？

`volatile`指易变的，表示变量可能在任何时候被外部因素修改，**编译器不应该对该变量的访问进行优化（不添加到缓存中，每次从内存中读取）**。在多线程编程中，`volatile`可以用于修饰共享变量，确保一个线程对变量的修改能被另一个线程立即看到。

#### 1.2.5 extern关键字的作用？

`extern`的作用主要为声明外部变量（全局变量、函数），告诉编译器这个变量或函数是**在其他文件中定义的，并且在当前文件中可以使用**。使用 `extern` 关键字可以帮助在多个源文件之间共享变量或函数，而不需要在每个文件中重复定义。

除此之外，在C++中引用C语言的代码时，需要告诉编译器按照 C 的链接规则处理这些函数，则需要通过 `extern "C"`来实现**，当在 C++ 代码中声明或定义 C 函数时，需要将函数声明放在 `extern "C"` 块中**。

#### 1.2.6 #define和typedef的区别？

它们都可以**用来创建别名**，但它们的用途和机制有很大不同。

- **处理阶段不同**：`#define`是预处理指令，在预处理阶段起作用；`typedef`是一个关键字，在编译阶段处理；
- **使用目的不同**：`#define`常用于定义常量、宏函数，在编译之前进行文本替换，还可以用于条件编译防止头文件重复定义；`typedef`主要用于创建现有复杂类型的别名，使得代码更加简化和具有可读性；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；`typedef`在编译时会进行类型检查；

#### 1.2.7 都能定义常量，#define和const的区别？

`#define` 和 `const` 都可以用来定义常量，但它们在使用方式、语法、作用域和编译时的处理上有很大的不同。以下是它们的主要区别：

- **处理阶段不同**：`#define`是预处理指令，在预处理阶段起作用；`const` 是一个关键字，在编译阶段处理；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；`const` 在编译时会进行类型检查，可以在编译时捕捉到类型相关的错误；
- **是否占用内存**：`#define`定义的常量是直接替换为了对应文本，不会占用内存；`const` 定义的常量会存在内存的常量区中，需要内存空间。

#### 1.2.8 #define和函数的区别？

`#define`宏和函数都**用于代码的重用**，允许定义一段代码然后再多个地方使用。它们的区别：

- **处理阶段不同**：`#define`是预处理器指令，在预处理阶段完成替换；函数是经过编译器编译生成可执行代码并链接，在运行时跳转到具体调用函数；
- **处理方式不同**：`#define`是直接文本替换，不存在函数调用，无需返回值；函数则需要跳转到具体调用位置执行，有返回值；
- **有无类型检查**：`#define`只是简单的字符串替换，没有类型检查；函数在编译时会进行类型检查；

### 1.3 数据类型和内存大小

|   类型    |  32位  |  64位  |
| :-------: | :----: | :----: |
|   char    | 1 字节 | 1 字节 |
|   short   | 2 字节 | 2 字节 |
|    int    | 4 字节 | 4 字节 |
|   float   | 4 字节 | 4 字节 |
|  double   | 8 字节 | 8 字节 |
|   long    | 4 字节 | 8 字节 |
| long long | 8 字节 | 8 字节 |
|   指针    | 4 字节 | 8 字节 |

### 1.4 字符串相关

#### 1.4.1 strlen和sizeof的区别？

- strlen是处理字符的**库函数**；sizeof是C++**运算符**，并不是函数，结果**在编译器获得**。
- strlen只能用于C风格字符串（以`'\0'`表示结尾）；sizeof可以用于任意数据的类型或数据本身。
- sizeof是在编译器获取结果，因此无法获取在运行期动态分配的空间大小；





### 1.x 其他基础内容

#### 1.x.1 变量的定义和声明的区别？

- 声明仅仅是将变量的位置和类型告诉编译器，并不实际为变量分配内存；定义是为变量分配内存空间。
- 相同的变量可以多次声明；但只能定义一次（分配一次内存）。

#### 1.x.2 C++和python的区别？

- C++是**编译型语言**，代码在允许前需要在**特定平台**编译成机器代码，后面就不需要再编译了；Python是**解释型语言**，每次都需要经过翻译和解释过程才可以执行。因此在实际运行中，C++通常具有更高的执行效率和性能，而Python方便跨平台，且开发速度快；
- C++需要**手动管理内存**，这也是C++语言的特色，可以有更高的性能但也容易出现内存泄漏等问题；Python有**自动垃圾回收机制**；
- C++定义变量是**静态类型**，在编译期确定，需要显示声明；Python变量是**动态类型**，在运行时确定，无需显式声明；
- C++适合系统编程、实时系统和高性能计算等需要高效的场景；Python适合Web开发、数据科学、机器学习、自动化脚本等设计开发。

#### 1.x.3 C++和JAVA的区别？

- C++是**编译型语言**，代码在允许前需要在**特定平台**编译成机器代码，后面就不需要再编译了；JAVA是**解释型语言**，需要编译成字节码，然后再JAVA虚拟机(JVM)上解释执行，可移植性更强；
- C++需要**手动管理内存**，这也是C++语言的特色，可以有更高的性能但也容易出现内存泄漏等问题；JAVA有**自动垃圾回收机制**；
- C++**支持指针**，允许直接操作内存地址；JAVA**不支持指针**，避免了直接对内存的操作，提高了安全性；
- C++既支持**面向过程也支持面向过程**；JAVA几乎所有代码**都是通过类和对象的形式**组织的；
- C++有丰富的标准库和第三方库，但使用起来比较复杂；JAVA拥有**庞大的标准库和第三方库生态系统**（如Spring），使用相对简单；
- C++通过**多继承、抽象类**等方式实现继承和多态；JAVA主要通过**接口**来实现，更加简易。
- C++适合系统编程、实时系统和高性能计算等需要高效的场景；JAVA适合企业级应用开发、Web开发、移动应用开发、分布式系统开发等。



## 2. 线程安全相关

### 2.1 a++ 和 int a = b 在C++中是否是线程安全的？

不安全。因为这些语句在编译为汇编指令**往往存在多条指令**，而多条指令就意味着可能存在线程安全问题。

```cpp
a++;
// 在汇编语言中存在三条指令：
// 1. 将a的内存值搬运到某个寄存器中
// 2. 将该寄存器中的值自增
// 3. 再将寄存器中的值搬运会a的内存中

int a = b;
// 在汇编语言中存在两条指令：（由于内存之间不能直接搬运，需要借助于寄存器）
// 1. 将b的值搬运到某个寄存器中
// 2. 再从该寄存器中搬运到a的内存地址
```

### 2.2 如何保证它们的原子性？

C++ 11中提供了一个新的原子操作库<atomic>，其中提供了一个模板类：`std::atomic`，可以保证一个变量的操作是原子的。它通过**底层的硬件指令（如 CPU 的原子操作指令）和内存屏障机制来实现原子性**，避免数据竞争（data race）问题。

```cpp
std::atomic<int> counter(0); // 定义一个原子整型变量

// 注意，这里不能用下面语句来定义，因为下面隐式的要调用拷贝构造函数，而std::atomic是利用=delete禁用拷贝构造函数的
std::atomic<int> counter = 0; ❌

// 在下面代码中的自增操作是原子的
void increment() {
    for (int i = 0; i < 1000; ++i) {
        ++counter; // 原子增操作
    }
}
```



## 3. C++内存模型

### 3.2 堆区和栈区

#### 3.2.1 堆区和栈区的区别？

- **申请方式不同**：栈是由系统自动分配和回收，堆需要由程序员显式的申请和回收；
- **大小不同**：栈由高地址向低地址扩展，大小是固定的且较小；堆由低地址向高地址扩展，更大；
- **效率不同**：栈区由系统自动分配，效率很高；堆区的分配效率较慢，且手动管理容易出现内存泄漏或内存碎片；
- **存储内容不同**：在C++中，栈区一般用来存储局部变量、函数参数和返回地址等；堆区用来存储用户动态创建的变量。

#### 3.2.2 堆区和栈区哪个效率更高，为什么？

栈区的效率通常比较高，原因：

- 栈区内存的分配和释放**由编译器自动管理**，内存分配通常是通过调整栈指针来完成，**简单高效**；而堆区的内存分配和释放需要**动态内存分配函数，涉及到包括查找适当大小的空闲块等操作，开销较大**；
- **栈内存是连续的**，局部变量通常紧密排列，符合CPU缓存的访问模式，访问效率高；**堆内存分配的块可能是离散的**，且随着不断的分配和释放**会碎片化**，访问效率降低；
- 栈区由于自动管理不易出错，而堆区容易导致**内存泄漏等问题**，增加了管理复杂性。



### 3.3 动态内存申请

#### 3.3.1 new/delete 和 malloc/free 的异同？

**相同点**：都是用来内存的动态申请和释放

**不同点**：

- new/delete 是C++的运算符；malloc/free 是C/C++的标准库函数
- new可以自动计算要分配的内存大小；malloc必须显式的指定
- new在分配内存失败时会抛出异常，不是返回NULL；malloc分配失败时返回NULL
- new/delete会调用对象的构造函数/析构函数；malloc/free不会
- new/delete返回的是具体类型指针；malloc/free返回的是void *，需要后续的类型转换

#### 3.3.2 既然已经有了malloc/free，为什么需要new/delete？

C++中引入了类和对象，对象创建的时候需要执行**构造函数**，销毁的时候需要调用**析构函数**。malloc/free不具有这个功能，而它们是标准库函数，已经编译了无法轻易地将构造函数和析构函数的功能加上去。因此，提出了new/delete运算符，能够在创建和销毁时去调用构造和析构函数。

#### 3.3.3 new/delete是如何实现的？

**new的实现**：先调用**operator new**标准库函数，分配足够大的原始为类型化的内存，然后运行该类型的构造函数，初始化构造对象，返回指向新分配并构造后对象的指针；

**delete的实现**：先对指向的对象运行析构函数，然后调用**operator delete**标准库函数释放该对象的内存。

#### 3.3.4 被free回收的内存是立刻还给操作系统吗？

不是。会**被ptmalloc使用双链表存起来**，当用户下一次申请内存时，会尝试从这个链表中寻找合适的内存，避免频繁的系统调用。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。